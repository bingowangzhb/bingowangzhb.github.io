<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="7. The IoC container[TOC] 7.1 Introduction to the Spring IoC container and beans This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) [1] principle. IoC is also kn">
<meta property="og:type" content="article">
<meta property="og:title" content="demo-blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;07&#x2F;demo-blog&#x2F;index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="7. The IoC container[TOC] 7.1 Introduction to the Spring IoC container and beans This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) [1] principle. IoC is also kn">
<meta property="og:locale" content="en">
<meta property="og:image" content="e:&#x2F;Documents&#x2F;hexo&#x2F;source&#x2F;_posts&#x2F;images&#x2F;container-magic.png">
<meta property="og:image" content="e:&#x2F;Documents&#x2F;hexo&#x2F;source&#x2F;_posts&#x2F;images&#x2F;singleton.png">
<meta property="og:image" content="e:&#x2F;Documents&#x2F;hexo&#x2F;source&#x2F;_posts&#x2F;images&#x2F;prototype.png">
<meta property="og:updated_time" content="2019-12-15T08:37:47.666Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="e:&#x2F;Documents&#x2F;hexo&#x2F;source&#x2F;_posts&#x2F;images&#x2F;container-magic.png">

<link rel="canonical" href="http://yoursite.com/2019/12/07/demo-blog/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>demo-blog | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/07/demo-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          demo-blog
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-07 12:16:26" itemprop="dateCreated datePublished" datetime="2019-12-07T12:16:26+08:00">2019-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-12-15 16:37:47" itemprop="dateModified" datetime="2019-12-15T16:37:47+08:00">2019-12-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="7-The-IoC-container"><a href="#7-The-IoC-container" class="headerlink" title="7. The IoC container"></a>7. The IoC container</h1><p>[TOC]</p>
<h2 id="7-1-Introduction-to-the-Spring-IoC-container-and-beans"><a href="#7-1-Introduction-to-the-Spring-IoC-container-and-beans" class="headerlink" title="7.1 Introduction to the Spring IoC container and beans"></a>7.1 Introduction to the Spring IoC container and beans</h2><blockquote>
<p>This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#ftn.d5e1829" target="_blank" rel="noopener">[1]</a> principle. IoC is also known as <em>dependency injection</em> (DI). It is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then <em>injects</em> those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name <em>Inversion of Control</em> (IoC), of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes, or a mechanism such as the <em>Service Locator</em> pattern.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">sth. is as known as sth.  被称为</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">whereby 凭借，依次</span></pre></td></tr></table></figure>

<p>这一章节介绍了控制反转（IoC）的Spring框架的实现。<strong>IoC也被称为依赖注入（DI），它是一个对象定义其依赖项的过程，也就是说，对象只通过构造函数参数、工厂方法的参数或对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义它们所使用的其他对象。</strong> 然后容器在创建bean的时候注入那些依赖项。这个过程本质上是相反的，因此名为“控制反转”，它通过直接构造类或使用诸如“服务定位器”模式之类的机制来控制其依赖项的实例化或位置。</p>
<blockquote>
<p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis for Spring Framework’s IoC container. The <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener"><code>BeanFactory</code></a> interface provides an advanced configuration mechanism capable of managing any type of object. <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/context/ApplicationContext.html" target="_blank" rel="noopener"><code>ApplicationContext</code></a> is a sub-interface of <code>BeanFactory</code>. It adds easier integration with Spring’s AOP features; message resource handling (for use in internationalization), event publication; and application-layer specific contexts such as the <code>WebApplicationContext</code> for use in web applications.</p>
</blockquote>
<p><code>org.springframework.beans</code>和<code>org.springframework.context</code>包是Spring框架IoC的基础。<code>BeanFactory</code>接口提供了一种高级配置机制，能够管理任何类型的对象。<code>ApplicationContext</code>是<code>BeanFactory</code>的子接口。它可以轻松地与SpringAOP功能集成，消息资源的处理（用于国际化），事件发布。以及特定于应用程序的context，比如用于web应用程序中的<code>WebApplicationContext</code></p>
<blockquote>
<p>In short, the <code>BeanFactory</code> provides the configuration framework and basic functionality, and the <code>ApplicationContext</code> adds more enterprise-specific functionality. The <code>ApplicationContext</code> is a complete superset of the <code>BeanFactory</code>, and is used exclusively in this chapter in descriptions of Spring’s IoC container. For more information on using the <code>BeanFactory</code> instead of the <code>ApplicationContext,</code> refer to <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-beanfactory" target="_blank" rel="noopener">Section 7.16, “The BeanFactory”</a>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">exclusively  adv. 排他地; 独占地; 专有地; 完全地</span></pre></td></tr></table></figure>

<p>简言之，<code>BeanFactory</code>提供了配置框架和基础的功能，而<code>ApplicationContext</code>添加了更多企业特有的功能。添加了是<code>BeanFactory</code>的一个完整超集，在本章中，只在描述SpringIoC容器时使用。更多关于使用<code>BeanFactory</code>而不是<code>ApplicationContext</code>的信息，请参考<code>Section 7.16, &quot;BeanFactory&quot;</code></p>
<blockquote>
<p>In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC <em>container</em> are called <em>beans</em>. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the <em>dependencies</em> among them, are reflected in the <em>configuration metadata</em> used by a container.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">backbone n. 脊柱； 骨干，中坚力量，支柱</span></pre></td></tr></table></figure>

<p>在Spring中，构成应用程序主干并且由SpringIoC容器管理的对象被称为bean。bean是由Spring IoC容器实例化，组装和以其他方式管理的对象。否则，bean仅仅是应用程序中众多对象之一。bean及其之间的依赖关系体现在，反应在容器使用的配置元数据中。</p>
<h2 id="7-2-Container-overview"><a href="#7-2-Container-overview" class="headerlink" title="7.2 Container overview"></a>7.2 Container overview</h2><blockquote>
<p> The interface <code>org.springframework.context.ApplicationContext</code> represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the aforementioned beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code. It allows you to express the objects that compose your application and the rich interdependencies between such objects.</p>
</blockquote>
<p><code>ApplicationContext</code>接口代表Spring IoC容器，并且负责实例化，配置，组装上述提到的bean。容器通过读取配置元数据获取有关对象实例化，配置和组装的指令。配置元数据以xml，java注解或者java代码来表示。它允许描述组成应用程序的对象以及这些对象之间丰富的相互依赖关系。</p>
<blockquote>
<p> Several implementations of the <code>ApplicationContext</code> interface are supplied out-of-the-box with Spring. In standalone applications it is common to create an instance of <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html" target="_blank" rel="noopener"><code>ClassPathXmlApplicationContext</code></a> or <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html" target="_blank" rel="noopener"><code>FileSystemXmlApplicationContext</code></a>. While XML has been the traditional format for defining configuration metadata you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats.</p>
</blockquote>
<p>Spring提供了<code>ApplicationContext</code>接口的几种开箱即用的实现方式。在独立的程序中，通常会创建<code>ClassPathXmlApplicationContext</code>或者<code>FileSystemXmlApplicationContext</code>实例。相比xml使用传统的格式来定义配置元数据，也可以提供少量的xml配置来声明启动对其他元数据格式的支持，使用java注解或者java代码形式来构建容器。</p>
<blockquote>
<p> In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the <code>web.xml</code> file of the application will typically suffice (see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#context-create" target="_blank" rel="noopener">Section 7.15.4, “Convenient ApplicationContext instantiation for web applications”</a>). If you are using the <a href="https://spring.io/tools/sts" target="_blank" rel="noopener">Spring Tool Suite</a> Eclipse-powered development environment this boilerplate configuration can be easily created with few mouse clicks or keystrokes.      boilerplate  n. 样板文件，文件范例</p>
</blockquote>
<p>在大多数应用场景中，不需要显示用户代码即可实例化Spring IoC的一个或多个实例。例如，在web应用场景中，通常在应用的xml文件中，简单的八行（大约）示例web描述符xml就足够了。</p>
<blockquote>
<p>The following diagram is a high-level view of how Spring works. Your application classes are combined with configuration metadata so that after the <code>ApplicationContext</code> is created and initialized, you have a fully configured and executable system or application.</p>
</blockquote>
<p>下图是Spring如何工作的高级视图。您的应用程序类和配置元数据结合在一起，以便在<code>ApplicationContext</code>创建初始化后，拥有完全配置和可执行的系统或者应用程序。</p>
<p><strong>Figure 7.1. The Spring IoC container</strong></p>
<p><img src="E:/Documents/hexo/source/_posts/images/container-magic.png" alt=""> </p>
<h3 id="7-2-1-Configuration-metadata"><a href="#7-2-1-Configuration-metadata" class="headerlink" title="7.2.1 Configuration metadata"></a>7.2.1 Configuration metadata</h3><blockquote>
<p>As the preceding diagram shows, the Spring IoC container consumes a form of <em>configuration metadata</em>; this configuration metadata represents how you as an application developer tell the Spring container to instantiate, configure, and assemble the objects in your application.</p>
</blockquote>
<p>如上图所示，Spring IoC容器使用一种形式的配置元数据。配置元数据表明你作为应用开发者，告诉Spring容器如何实例化，配置和组装应用中的对象</p>
<blockquote>
<p>Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">intuitive adj. 直觉的，直觉获知的，直观的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">convey v. 传达，传递，表示</span></pre></td></tr></table></figure>

<p>传统情况下，配置元数据以简单直观的xml格式提供，本章大部分以此来传达Spring IoC容器的关键概念和功能</p>
<blockquote>
<blockquote>
<p>XML-based metadata is <em>not</em> the only allowed form of configuration metadata. The Spring IoC container itself is <em>totally</em> decoupled from the format in which this configuration metadata is actually written. These days many developers choose <a href="https://docs.spring.io/spring/docs/4.3.x/spring-framework-reference/htmlsingle/#beans-java" target="_blank" rel="noopener">Java-based configuration</a> for their Spring applications.  decouple v. 分离</p>
</blockquote>
<p> 基于xml的元数据不是配置元数据的唯一允许形式。Spring IoC容器本身和实际被写入配置元数据的形式是不相关的。如今，很多开发人员选择基于java 代码的配置来构建Spring应用程序</p>
</blockquote>
<blockquote>
<p> For information about using other forms of metadata with the Spring container, see:</p>
<ul>
<li><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-annotation-config" target="_blank" rel="noopener">Annotation-based configuration</a>: Spring 2.5 introduced support for annotation-based configuration metadata.</li>
<li><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-java" target="_blank" rel="noopener">Java-based configuration</a>: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus you can define beans external to your application classes by using Java rather than XML files. To use these new features, see the <code>@Configuration</code>, <code>@Bean</code>, <code>@Import</code> and <code>@DependsOn</code> annotations.</li>
</ul>
</blockquote>
<p>Spring容器元数据的其他情形时：</p>
<ul>
<li>基于注解的配置</li>
<li>基于java代码的配置</li>
</ul>
<blockquote>
<p>Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata shows these beans configured as <code>elements inside a top-level</code> element. Java configuration typically uses <code>@Bean</code> annotated methods within a <code>@Configuration</code> class.</p>
</blockquote>
<p>Spring配置由一个通常情况下至少一个bean定义组成，bean定义必须由容器管理。基于xml的配置元数据表明这些bean被配置为顶级元素中的元素。java配置通常在<code>@Configuration</code>注解的类中带有<code>@Bean</code>注解的方法</p>
<blockquote>
<p>These bean definitions correspond to the actual objects that make up your application. Typically you define service layer objects, data access objects (DAOs), presentation objects such as Struts <code>Action</code> instances, infrastructure objects such as Hibernate <code>SessionFactories</code>, JMS <code>Queues</code>, and so forth. Typically one does not configure fine-grained domain objects in the container, because it is usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring’s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#aop-atconfigurable" target="_blank" rel="noopener">Using AspectJ to dependency-inject domain objects with Spring</a>.</p>
</blockquote>
<p>应用程序由这些bean定义对应的实际对象组成。通常，定义服务层对象，数据访问对象，表示层对象例如Struts Action实例，基础对象例如Hibernate <code>SessionFactories</code>, JMS<code>Queues</code>等等。通常不会在容器中配置细粒度的域对象，因为创建和加载域对象通常是DAO和业务逻辑的职责。但是，可以使用Spring整合AspectJ来配置IoC容器控制外的已创建的对象。</p>
<blockquote>
<p>The following example shows the basic structure of XML-based configuration metadata:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- more bean definitions go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>id</code> attribute is a string that you use to identify the individual bean definition. The <code>class</code> attribute defines the type of the bean and uses the fully qualified classname. The value of the id attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example; see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-dependencies" target="_blank" rel="noopener">Dependencies</a> for more information.</p>
</blockquote>
<p>id属性是个字符串，可以用来标识单个bean定义。class属性定义了bean的类型，并使用全类名。id属性的值表示协作对象。引用协作对象的xml并未在此例中展示。</p>
<h3 id="7-2-2-Instantiating-a-container"><a href="#7-2-2-Instantiating-a-container" class="headerlink" title="7.2.2 Instantiating a container"></a>7.2.2 Instantiating a container</h3><blockquote>
<p>Instantiating a Spring IoC container is straightforward. The location path or paths supplied to an <code>ApplicationContext</code> constructor are actually resource strings that allow the container to load configuration metadata from a variety of external resources such as the local file system, from the Java <code>CLASSPATH</code>, and so on.</p>
</blockquote>
<p>实例化Spring IoC容器简单明了。提供给<code>ApplicationContext</code>构造方法的路径或多个路径通常是资源字符串，它允许容器从各种外部资源，例如本地文件系统，java classpath等加载配置元数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<p>After you learn about Spring’s IoC container, you may want to know more about Spring’s <code>Resource</code> abstraction, as described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#resources" target="_blank" rel="noopener">Chapter 8, <em>Resources</em></a>, which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, <code>Resource</code> paths are used to construct applications contexts as described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#resources-app-ctx" target="_blank" rel="noopener">Section 8.7, “Application contexts and Resource paths”</a>.</p>
</blockquote>
<p>学习完Spring IoC容器后，你可能像知道更多关于Spring的<code>Resource</code>的抽象概念，在第八章描述，提供了一种便捷机制，用于从URI语法定义的位置读取InputSteam</p>
</blockquote>
<blockquote>
<p>The following example shows the service layer objects <code>(services.xml)</code> configuration file:</p>
</blockquote>
<p>service层对象配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- services --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"petStore"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.services.PetStoreServiceImpl"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accountDao"</span> <span class="attr">ref</span>=<span class="string">"accountDao"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"itemDao"</span> <span class="attr">ref</span>=<span class="string">"itemDao"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- more bean definitions for services go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The following example shows the data access objects <code>daos.xml</code> file:</p>
</blockquote>
<p>dao层对象配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemDao"</span> <span class="attr">class</span>=<span class="string">"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- more bean definitions for data access objects go here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>In the preceding example, the service layer consists of the class <code>PetStoreServiceImpl</code>, and two data access objects of the type <code>JpaAccountDao</code> and <code>JpaItemDao</code> (based on the JPA Object/Relational mapping standard). The <code>property name</code> element refers to the name of the JavaBean property, and the <code>ref</code> element refers to the name of another bean definition. This linkage between <code>id</code> and <code>ref</code> elements expresses the dependency between collaborating objects. For details of configuring an object’s dependencies, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-dependencies" target="_blank" rel="noopener">Dependencies</a>.</p>
</blockquote>
<p>在上述例子中，service层由类<code>PetStoreServiceImpl</code>和两个dao对象<code>JpaAccountDao</code>与<code>JpaItemDao</code>组成。<code>property name</code>元素表示JavaBean的属性的名字，<code>ref</code>元素表示另一个bean定义的名字。<code>id</code>和<code>ref</code>之间的联系表明了协作对象之间的依赖关系。</p>
<h4 id="Composing-XML-based-configuration-metadata"><a href="#Composing-XML-based-configuration-metadata" class="headerlink" title="Composing XML-based configuration metadata"></a>Composing XML-based configuration metadata</h4><p>组成基于XML的配置元数据</p>
<blockquote>
<p>It can be useful to have bean definitions span multiple XML files. Often each individual XML configuration file represents a logical layer or module in your architecture.</p>
<p>You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the previous section. Alternatively, use one or more occurrences of the `` element to load bean definitions from another file or files. For example:</p>
</blockquote>
<p>bean定义跨多个xml文件可能会很有用。通常每个单个xml配置文件代表着架构中一个逻辑层或者模块</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"services.xml"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"resources/messageSource.xml"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"/resources/themeSource.xml"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean1"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bean2"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>In the preceding example, external bean definitions are loaded from three files: <code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. All location paths are relative to the definition file doing the importing, so <code>services.xml</code> must be in the same directory or classpath location as the file doing the importing, while <code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the location of the importing file. As you can see, a leading slash is ignored, but given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must be valid XML bean definitions according to the Spring Schema.</p>
</blockquote>
<p>上述例子中，加载了三个外部的bean定义的文件：<code>services.xml, messageSource.xml,themeSource.xml</code>。导入的所有定义文件的路径是相对的，因此当导入的时候，<code>services.xml</code>必须位于相同的目录或者classpath位置，而<code>messageSource.xml，themeSource.xml</code>必须位于当前导入位置下的<code>resources</code>位置下。如你所见，路径中的斜杠被忽略，给予的这些路径都是相对的。最好不要使用斜杠。被导入的文件内容，包括顶级的<code>&lt;bean/&gt;</code>元素必须是基于Spring Schema有效的xml bean定义</p>
<blockquote>
<blockquote>
<p>It is possible, but not recommended, to reference files in parent directories using a relative “../“ path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for “classpath:” URLs (for example, “classpath:../services.xml”), where the runtime resolution process chooses the “nearest” classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory.</p>
</blockquote>
<p>可以但不推荐使用相对的<code>../</code>路径来导入父目录的文件。这样做会创建对当前应用程序外部文件的依赖关系。特别地，引用不推荐用”classpath:”这样的URL（例如， “classpath:../services.xml”）, 运行时解析过程会选择最近的classpath根目录，然后寻找父目录。classpath配置的更改可能导致会选择不同的，错误的目录。</p>
<blockquote>
<p>You can always use fully qualified resource locations instead of relative paths: for example, “file:C:/config/services.xml” or “classpath:/config/services.xml”. However, be aware that you are coupling your application’s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations, for example, through “${…}” placeholders that are resolved against JVM system properties at runtime.</p>
</blockquote>
<p>你始终可以使用全路径资源位置来代替相对路径：例如，“file:C/config/services.xml” 或者 “classpath:/config/services.xml”. 当时，注意你正在将应用程序的配置耦合到特定的绝对位置。通常，最好对这样的绝对位置保留一个间接寻址，例如，通过“${}” 占位符， 用于运行时针对JVM系统属性的解析</p>
</blockquote>
<blockquote>
<p>The import directive is a feature provided by the beans namespace itself. Further configuration features beyond plain bean definitions are available in a selection of XML namespaces provided by Spring, e.g. the “context” and the “util” namespace.</p>
</blockquote>
<p>import伪指令是bean名称空间本身提供的功能。 Spring提供的一系列XML名称空间提供了除普通bean定义之外的其他配置功能，例如 “context”和“ util”命名空间。</p>
<h3 id="7-2-3-Using-the-container"><a href="#7-2-3-Using-the-container" class="headerlink" title="7.2.3 Using the container"></a>7.2.3 Using the container</h3><p>使用容器</p>
<blockquote>
<p>The <code>ApplicationContext</code> is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. Using the method <code>T getBean(String name, Class requiredType)</code> you can retrieve instances of your beans.</p>
<p>The <code>ApplicationContext</code> enables you to read bean definitions and access them as follows:</p>
</blockquote>
<p><code>ApplicationContext</code>是一个具有管理不同bean及其依赖的高级工厂的接口。<code>ApplicationContext</code>让你能都读取bean定义，并访问他们，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// create and configure beans</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// retrieve configured instance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">PetStoreService service = context.getBean(<span class="string">"petStore"</span>, PetStoreService<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// use configured instance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; userList = service.getUsernameList();</span></pre></td></tr></table></figure>

<blockquote>
<p>With Groovy configuration, bootstrapping looks very similar, just a different context implementation class which is Groovy-aware (but also understands XML bean definitions):</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> GenericGroovyApplicationContext(<span class="string">"services.groovy"</span>, <span class="string">"daos.groovy"</span>);</span></pre></td></tr></table></figure>

<blockquote>
<p>The most flexible variant is <code>GenericApplicationContext</code> in combination with reader delegates, e.g. with <code>XmlBeanDefinitionReader</code> for XML files:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context = <span class="keyword">new</span> GenericApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> XmlBeanDefinitionReader(context).loadBeanDefinitions(<span class="string">"services.xml"</span>, <span class="string">"daos.xml"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">context.refresh();</span></pre></td></tr></table></figure>

<blockquote>
<p> Or with <code>GroovyBeanDefinitionReader</code> for Groovy files:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">GenericApplicationContext context &#x3D; new GenericApplicationContext();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">new GroovyBeanDefinitionReader(context).loadBeanDefinitions(&quot;services.groovy&quot;, &quot;daos.groovy&quot;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">context.refresh();</span></pre></td></tr></table></figure>



<blockquote>
<p>You can then use <code>getBean</code> to retrieve instances of your beans. The <code>ApplicationContext</code> interface has a few other methods for retrieving beans, but ideally your application code should never use them. Indeed, your application code should have no calls to the <code>getBean()</code> method at all, and thus no dependency on Spring APIs at all. For example, Spring’s integration with web frameworks provides dependency injection for various web framework components such as controllers and JSF-managed beans, allowing you to declare a dependency on a specific bean through metadata (e.g. an autowiring annotation).</p>
</blockquote>
<p>你可以使用<code>getBean</code>方法检索获取你的bean实例。<code>ApplicationContext</code>接口拥有一些其他获取bean的方法，但是理想情况下，你的应用程序代码永远不要使用他们。事实上，你的应用程序代码完全不应该调用<code>getBean</code>方法，因此完全不依赖于Spring APIs。例如，Spring对web框架的整合提供了多种web框架组件的依赖注入，例如控制器，jsf管理bean，这允许你通过元数据来声明特定bean的依赖（比如，autowire 注解）</p>
<h2 id="7-3-Bean-overview"><a href="#7-3-Bean-overview" class="headerlink" title="7.3 Bean overview"></a>7.3 Bean overview</h2><p>bean 概览</p>
<blockquote>
<p>A Spring IoC container manages one or more <em>beans</em>. These beans are created with the configuration metadata that you supply to the container, for example, in the form of XML <code>&lt;bean/&gt;</code> definitions.</p>
</blockquote>
<p>Spring IoC容器管理一个或多个bean。这些bean通过提供给容器的配置元数据创建，例如，以xml bean定义的形式</p>
<blockquote>
<p>Within the container itself, these bean definitions are represented as <code>BeanDefinition</code> objects, which contain (among other information) the following metadata:</p>
<ul>
<li><em>A package-qualified class name:</em> typically the actual implementation class of the bean being defined.</li>
<li>Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth).</li>
<li>References to other beans that are needed for the bean to do its work; these references are also called <em>collaborators</em> or <em>dependencies</em>.</li>
<li>Other configuration settings to set in the newly created object, for example, the number of connections to use in a bean that manages a connection pool, or the size limit of the pool.</li>
</ul>
</blockquote>
<p>在容器本身内部，这些bean定义表示为<code>BeanDefinition</code>对象，包含（除其他信息外）以下信息：</p>
<ul>
<li>合格的包类名：通常是定义bean的实际的实现类</li>
<li>Bean行为配置元素，用于声明bean在容器中具有何种行为（作用域，生命周期回调，等等）</li>
<li>bean完成工作时所需的其他bean的引用。也被称为协作者或者依赖项</li>
<li>在新创建对象中的其他配置设置，例如，用于管理连接池的bean中使用的连接数，或该池的大小</li>
</ul>
<blockquote>
<p>This metadata translates to a set of properties that make up each bean definition.</p>
</blockquote>
<p><strong>Table 7.1. The bean definition</strong></p>
<blockquote>
<table>
<thead>
<tr>
<th>Property</th>
<th>Explained in…</th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-class" target="_blank" rel="noopener">Section 7.3.2, “Instantiating beans”</a></td>
</tr>
<tr>
<td>name</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-beanname" target="_blank" rel="noopener">Section 7.3.1, “Naming beans”</a></td>
</tr>
<tr>
<td>scope</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="noopener">Section 7.5, “Bean scopes”</a></td>
</tr>
<tr>
<td>constructor arguments</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-collaborators" target="_blank" rel="noopener">Section 7.4.1, “Dependency Injection”</a></td>
</tr>
<tr>
<td>properties</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-collaborators" target="_blank" rel="noopener">Section 7.4.1, “Dependency Injection”</a></td>
</tr>
<tr>
<td>autowiring mode</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-autowire" target="_blank" rel="noopener">Section 7.4.5, “Autowiring collaborators”</a></td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-lazy-init" target="_blank" rel="noopener">Section 7.4.4, “Lazy-initialized beans”</a></td>
</tr>
<tr>
<td>initialization method</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener">the section called “Initialization callbacks”</a></td>
</tr>
<tr>
<td>destruction method</td>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener">the section called “Destruction callbacks”</a></td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p> In addition to bean definitions that contain information on how to create a specific bean, the <code>ApplicationContext</code> implementations also permit the registration of existing objects that are created outside the container, by users. This is done by accessing the ApplicationContext’s BeanFactory via the method <code>getBeanFactory()</code> which returns the BeanFactory implementation <code>DefaultListableBeanFactory</code>. <code>DefaultListableBeanFactory</code> supports this registration through the methods <code>registerSingleton(..)</code> and <code>registerBeanDefinition(..)</code>. However, typical applications work solely with beans defined through metadata bean definitions.    solely = only</p>
</blockquote>
<p>除了包含有关如何创建特定bean的信息的bean外，<code>ApplicationContext</code>实现也允许用户在容器外部创建的现有对象的注册。通过<code>getBeanFactory()</code>方法访问<code>ApplicationContext</code>的<code>BeanFactory</code>来完成，该方法返回<code>BeanFactory</code>的实现类<code>DefaultListableBeanFactory</code>。<code>DefaultListableBeanFactory</code>通过方法<code>registerSingleton(..)</code>和<code>registerBeanDefinition(..)</code>支持这种注册。但是，典型应用只能与通过bean定义的元数据定义的bean一起使用。</p>
<blockquote>
<blockquote>
<p>Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding of existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to factory) is not officially supported and may lead to concurrent access exceptions and/or inconsistent state in the bean container.</p>
</blockquote>
<p> Bean元数据和手动提供的单实例需要<strong>尽早注册</strong>，以便容器在自动装备和其他自省步骤中准确地推理他们。虽然某种程度上支持覆盖现有元数据和现有的单例实例，但未正式支持在运行时（对工厂实时访问同时）对新bean的注册，并且可能导致容器中并发访问异常或状态不一致</p>
</blockquote>
<h3 id="7-3-1-Naming-beans"><a href="#7-3-1-Naming-beans" class="headerlink" title="7.3.1 Naming beans"></a>7.3.1 Naming beans</h3><p>命名bean</p>
<blockquote>
<p>Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier, but if it requires more than one, the extra ones can be considered aliases.</p>
</blockquote>
<p>每个bean具有一个或多个标识符。这些标识符在承载bean的容器中必须唯一。一个bean通常仅有一个标识符，但是如果需要多个，多余的可以被视为别名</p>
<blockquote>
<p>In XML-based configuration metadata, you use the <code>id</code> and/or <code>name</code> attributes to specify the bean identifier(s). The <code>id</code> attribute allows you to specify exactly one id. Conventionally these names are alphanumeric (‘myBean’, ‘fooService’, etc.), but may contain special characters as well. If you want to introduce other aliases to the bean, you can also specify them in the <code>name</code> attribute, separated by a comma (<code>,</code>), semicolon (<code>;</code>), or white space. As a historical note, in versions prior to Spring 3.1, the <code>id</code> attribute was defined as an <code>xsd:ID</code> type, which constrained possible characters. As of 3.1, it is defined as an <code>xsd:string</code> type. Note that bean <code>id</code> uniqueness is still enforced by the container, though no longer by XML parsers.</p>
</blockquote>
<p>基于xml配置的元数据中，可以使用<code>id</code>或者<code>name</code>属性来指定bean的标识符。<code>id</code>属性允许精确指定一个。按照惯例这些名字是字母数字的（“myBean”， “fooService”，等等），但是有可能包含特殊字符。如果你想向bean引入其他别名，可以在<code>name</code>属性中指定他们，并用逗号、分号或者空格分隔。作为历史记录，Spring 3.1之前，id属性被定义为一个<code>xsd:ID</code>类型，该类型限制了可能的字符串。从3.1开始，它被定义为<code>xsd:string</code>类型。注意bean的<code>id</code>属性的唯一性仍由容器强制，尽管xml解析器不在解析</p>
<blockquote>
<p>You are not required to supply a name or id for a bean. If no name or id is supplied explicitly, the container generates a unique name for that bean. However, if you want to refer to that bean by name, through the use of the <code>ref</code> element or <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-servicelocator" target="_blank" rel="noopener">Service Locator</a> style lookup, you must provide a name. Motivations for not supplying a name are related to using <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-inner-beans" target="_blank" rel="noopener">inner beans</a> and <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-autowire" target="_blank" rel="noopener">autowiring collaborators</a>.</p>
</blockquote>
<p>不必为一个bean提供<code>id</code>或者<code>name</code>.如果没有显示提供<code>id</code>或者<code>name</code>，容器会为bean生成一个唯一的<code>name</code>。但是，如果你想使用<code>ref</code>元素或者服务定位器风格检索，根据<code>name</code>引用该bean，你必须提供一个<code>name</code>。不提供<code>name</code>的使用动机与使用内部类和自动装配依赖有关</p>
<blockquote>
<p><strong>Bean Naming Conventions</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter, and are camel-cased from then on. Examples of such names would be (without quotes) &#39;accountManager&#39;, &#39;accountService&#39;, &#39;userDao&#39;, &#39;loginController&#39;, and so forth.</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Naming beans consistently makes your configuration easier to read and understand, and if you are using Spring AOP it helps a lot when applying advice to a set of beans related by name.</span></pre></td></tr></table></figure>

<p>Bean命名约定</p>
<p>约定是在命名bean时使用标准的java实例域名称约定。也就是说bean名称以小写字母开头，从那开始以驼峰表示。示例为accountManager,  accountService, userDao, loginController等</p>
<p>一致的命名bean使得配置易于阅读和理解，并且如果你使用Spring AOP，当将advice应用于按照name相关的bean时，它会很有用。</p>
</blockquote>
<blockquote>
<blockquote>
<p> With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules above: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by <code>java.beans.Introspector.decapitalize</code> (which Spring is using here). </p>
</blockquote>
<p> 通过类路径进行组件扫描，Spring遵循上述规则为未命名的组件生成bean名称： 本质上，采用简单的类名称并且将其初始字符转换为小写。但是特殊情况下，如果有多个字符并且第一个和第二个字符均为大写字母，则会保留原始大小写。这些规则与<code>java.beans.Introspector.decapitalize</code>（spring在这里使用）定义的规则相同</p>
</blockquote>
<h4 id="Aliasing-a-bean-outside-the-bean-definition"><a href="#Aliasing-a-bean-outside-the-bean-definition" class="headerlink" title="Aliasing a bean outside the bean definition"></a>Aliasing a bean outside the bean definition</h4><blockquote>
<p>In a bean definition itself, you can supply more than one name for the bean, by using a combination of up to one name specified by the <code>id</code> attribute, and any number of other names in the <code>name</code> attribute. These names can be equivalent aliases to the same bean, and are useful for some situations, such as allowing each component in an application to refer to a common dependency by using a bean name that is specific to that component itself.</p>
</blockquote>
<p>在bean定义本身中，通过使用id属性可以指定至多一个name和使用name属性指定做个其他name的联合，你可以为bean提供多个name。这些name是同一个bean对的等效名称，在某些情况下很有用，比如，允许应用程序中的每个组件通过使用特定于该组件本身的bean名称来引用公共依赖。</p>
<blockquote>
<p>Specifying all aliases where the bean is actually defined is not always adequate, however. It is sometimes desirable to introduce an alias for a bean that is defined elsewhere. This is commonly the case in large systems where configuration is split amongst each subsystem, each subsystem having its own set of object definitions. In XML-based configuration metadata, you can use the <code>&lt;alias/&gt;</code> element to accomplish this.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">adequate adj. 足够的，合格的，可用的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">desirable adj.  值得想望（或拥有）的;合意的;可取的;受欢迎的</span></pre></td></tr></table></figure>

<p>但是，在实际bean定义的地方，指定多个别名通常是不够的。有时需要为在其他地方定义的bean引进一个别名。在大型系统中通常是这种情况，配置文件分割到每个子系统，每个子系统拥有它自己的一套对象定义。在基于xml配置元数据中，可以使用<code>&lt;alias/&gt;</code>元素来完成。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"fromName"</span> <span class="attr">alias</span>=<span class="string">"toName"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>In this case, a bean (in the same container) named <code>fromName</code> may also, after the use of this alias definition, be referred to as <code>toName</code>.</p>
</blockquote>
<p>该例中，名为<code>fromName</code>的bean（相同容器中），使用定义别名后，也可以通过<code>toName</code>来引用</p>
<blockquote>
<p>For example, the configuration metadata for subsystem A may refer to a DataSource by the name of <code>subsystemA-dataSource</code>. The configuration metadata for subsystem B may refer to a DataSource by the name of <code>subsystemB-dataSource</code>. When composing the main application that uses both these subsystems, the main application refers to the DataSource by the name of <code>myApp-dataSource</code>. To have all three names refer to the same object, you can add the following alias definitions to the configuration metadata:</p>
</blockquote>
<p>例如，子系统A的元数据可能引用DataSource实例通过bean名称<code>subsystemA-datasource</code>。 子系统B引用<code>subsystemB-datasource</code>。当使用这两个子系统来组成主要的应用程序时。主应用可以通过<code>myApp-dataSource</code>引用DataSource。要使三个名称引用相同的对象，可以将下列别名定义添加到配置元数据中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"myApp-dataSource"</span> <span class="attr">alias</span>=<span class="string">"subsystemA-dataSource"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"myApp-dataSource"</span> <span class="attr">alias</span>=<span class="string">"subsystemB-dataSource"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Now each component and the main application can refer to the dataSource through a name that is unique and guaranteed not to clash with any other definition (effectively creating a namespace), yet they refer to the same bean.  clash v. 冲突，不容合</p>
</blockquote>
<p>现在每个组件和主要的应用程序通过一个唯一的名称引用dataSource对象，且与其他定义名称不冲突。（有效地创建命名空间）。但他们引用的是同一个bean</p>
<blockquote>
<p><strong>Java-configuration</strong></p>
<p>If you are using Java-configuration, the <code>@Bean</code> annotation can be used to provide aliases see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-java-bean-annotation" target="_blank" rel="noopener">Section 7.12.3, “Using the @Bean annotation”</a> for details.</p>
</blockquote>
<h3 id="7-3-2-Instantiating-beans"><a href="#7-3-2-Instantiating-beans" class="headerlink" title="7.3.2 Instantiating beans"></a>7.3.2 Instantiating beans</h3><p>实例化 bean</p>
<blockquote>
<p>A bean definition essentially is a recipe for creating one or more objects. The container looks at the recipe for a named bean when asked, and uses the configuration metadata encapsulated by that bean definition to create (or acquire) an actual object.    recipe n. 食谱，配方，方法。</p>
</blockquote>
<p>Bean定义本质上是创建一个或多个对象的方法。 询问时，容器将查看命名bean的配方，并使用该bean定义封装的配置元数据来创建（或获取）实际对象。 </p>
<blockquote>
<p>If you use XML-based configuration metadata, you specify the type (or class) of object that is to be instantiated in the <code>class</code> attribute of the <code>element</code>. This <code>class</code> attribute, which internally is a <code>Class</code> property on a <code>BeanDefinition</code> instance, is usually mandatory. For exceptions, see [the section called “Instantiation using an instance factory method”]and [Section 7.7, “Bean definition inheritance”]。You use the <code>Class</code> property in one of two ways:</p>
<ul>
<li>Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code using the new operator.</li>
<li>To specify the actual class containing the static factory method that will be invoked to create the object, in the less common case where the container invokes a static factory method on a class to create the bean. The object type returned from the invocation of the static factory method may be the same class or another class entirely. </li>
</ul>
</blockquote>
<p>如果你使用基于xml的配置元数据，可以通过元素的<code>class</code>属性来指定将要被实例化对象的类型或者类。<code>class</code>属性，在<code>BeanDefinition</code>内部是一个<code>Class</code>属性，通常是必须的。通过两种方式使用<code>Class</code>属性：</p>
<ul>
<li>通常这种情况下指定要构造bean的class，容器本事直接通过反射调用其构造方法来创建bean，有点类似java代码中的new操作符</li>
<li>指定实际类包含的静态工厂方法，通过调用该方法来创建对象，不常见的情况下，容器调用类的静态工厂方法来创建bean。静态方法调用后返回的对象类型可能是同一个类或者是完全不同的另一个类。</li>
</ul>
<blockquote>
<p><strong>Inner class names.</strong> </p>
<p>If you want to configure a bean definition for a <code>static</code> nested class, you have to use the <em>binary</em> name of the nested class.</p>
<p>For example, if you have a class called <code>Foo</code> in the <code>com.example</code> package, and this <code>Foo</code> class has a <code>static</code> nested class called <code>Bar</code>, the value of the <code>&#39;class&#39;</code> attribute on a bean definition would be…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">com.example.Foo$Bar</span></pre></td></tr></table></figure>

<p>Notice the use of the <code>$</code> character in the name to separate the nested class name from the outer class name.</p>
</blockquote>
<p>内部类名</p>
<p>如果想配置静态内部类的bean定义，就需要使用内部类的二进制名称</p>
<p>例如， 一个在<code>com.example</code>包下的<code>Foo</code>类， 这个类有一个静态内部类<code>Bar</code>, 则这个bean定义中<code>class</code>属性的将是<code>com.example.Foo$Bar</code>, <code>&amp;</code>用于分隔内部类名和外部类名</p>
<h4 id="Instantiation-with-a-constructor"><a href="#Instantiation-with-a-constructor" class="headerlink" title="Instantiation with a constructor"></a>Instantiation with a constructor</h4><p> 构造方法实例化</p>
<blockquote>
<p>When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice. However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor.</p>
</blockquote>
<p>使用构造方法创建bean时，所有普通类都可以被Spring使用并与之兼容。也就是说，正在被开发的类不需要实现特定接口或者以特定的方式编码。仅指定bean的class就足够了。但是，取决于你使用特定bean的IoC类型，你可能需要一个默认的构造方法</p>
<blockquote>
<p>The Spring IoC container can manage virtually <em>any</em> class you want it to manage; it is not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (no-argument) constructor and appropriate setters and getters modeled after the properties in the container. You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">virtually adv.几乎;实际上;事实上;差不多</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">appropriate adj.  适当的;合适的;恰当的 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">exotic adj. 具有异国情调的;外来的;奇异的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">legacy n.（事件或历史的）遗留问题，后遗症 ； 遗产；遗赠</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">adhere v. 遵守，遵循（规定或协议）</span></pre></td></tr></table></figure>

<p>Spring IoC 容器几乎可以管理你所期望的任何类。它不限于管理真正的javaBean。大多Spring使用者更喜欢实际的</p>
<blockquote>
<p>With XML-based configuration metadata you can specify your bean class as follows: </p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"anotherExample"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBeanTwo"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>For details about the mechanism for supplying arguments to the constructor (if required) and setting object instance properties after the object is constructed, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-collaborators" target="_blank" rel="noopener">Injecting Dependencies</a>.</p>
</blockquote>
<p>构造完对象后，关于构造方法参数提供和设置对象属性机制的详细内容，参见Injecting Dependecies</p>
<h4 id="Instantiation-with-a-static-factory-method"><a href="#Instantiation-with-a-static-factory-method" class="headerlink" title="Instantiation with a static factory method"></a>Instantiation with a static factory method</h4><p>静态工厂方法实例化</p>
<blockquote>
<p>When defining a bean that you create with a static factory method, you use the <code>class</code> attribute to specify the class containing the <code>static</code> factory method and an attribute named <code>factory-method</code> to specify the name of the factory method itself. You should be able to call this method (with optional arguments as described later) and return a live object, which subsequently is treated as if it had been created through a constructor. One use for such a bean definition is to call <code>static</code> factories in legacy code.</p>
</blockquote>
<p>当定义一个使用静态工厂方法创建bean的bean定义时，需要指定<code>class</code>属性为持有静态工厂的类，并且指定<code>factory-method</code>属性为工厂方法本身。你应当能够调用这个方法（使用后续描述的可选参数）并且返回一个活的对象，随后即被称之为通过构造方法创建bean。这种bean定义的一种用法是在旧版代码中调用“静态”工厂。</p>
<blockquote>
<p>The following bean definition specifies that the bean will be created by calling a factory-method. The definition does not specify the type (class) of the returned object, only the class containing the factory method. In this example, the <code>createInstance()</code> method must be a <em>static</em> method.</p>
</blockquote>
<p>以下bean定义指定了bean创建时调用的工厂方法。定义不指定返回对象的类型，而是包含工厂方法的类。此例中，<code>createInstance()</code>方法必须是一个静态方法</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span> <span class="attr">class</span>=<span class="string">"examples.ClientService"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> clientService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p> For details about the mechanism for supplying (optional) arguments to the factory method and setting object instance properties after the object is returned from the factory, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-properties-detailed" target="_blank" rel="noopener">Dependencies and configuration in detail</a>.</p>
</blockquote>
<h4 id="Instantiation-using-an-instance-factory-method"><a href="#Instantiation-using-an-instance-factory-method" class="headerlink" title="Instantiation using an instance factory method"></a>Instantiation using an instance factory method</h4><p>实例工厂方法实例化</p>
<blockquote>
<p>Similar to instantiation through a static factory method, instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean. <strong>To use this mechanism, leave the class attribute empty, and in the factory-bean attribute, specify the name of a bean in the current (or parent/ancestor) container that contains the instance method that is to be invoked to create the object.</strong> Set the name of the factory method itself with the factory-method attribute.</p>
</blockquote>
<p>与静态工厂方法实例化类似，实力工厂方法实例化调用容器中现有bean的非静态方法来创建新的bean。使用这种机制，<code>class</code>属性为空，且<code>factory-bean</code>属性指定当前容器包含实例方法的bean名称，调用该实例方法来创建对象。使用<code>factory-method</code>属性来设置工厂方法的名称</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the bean to be created via the factory bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span> <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span> <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> PersonService personService = <span class="keyword">new</span> PersonService();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> AccountService accountService = <span class="keyword">new</span> AccountService();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> PersonService <span class="title">createPersonService</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> personService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountService</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> accountService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p> This approach shows that the factory bean itself can be managed and configured through dependency injection (DI). See <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-properties-detailed" target="_blank" rel="noopener">Dependencies and configuration in detail</a>.</p>
</blockquote>
<p>这个方法表明，工厂bean本身通过依赖注入被管理和配置</p>
<blockquote>
<p>[Note]</p>
<p>In Spring documentation, factory bean refers to a bean that is configured in the Spring container that will create objects through an instance or static factory method. By contrast, FactoryBean (notice the capitalization) refers to a Spring-specific FactoryBean.</p>
</blockquote>
<p>在Spring文档中，工厂bean指的是这样一个bean，在Spring容器中配置，通过实例或者静态工厂方法创建对象。相比之下，<code>FactoryBean</code>指的是Spring特定的FactoryBean</p>
<h2 id="7-4-Dependencies"><a href="#7-4-Dependencies" class="headerlink" title="7.4 Dependencies"></a>7.4 Dependencies</h2><blockquote>
<p>A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application. This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal.</p>
</blockquote>
<p>典型的企业应用不会由单个对象（Spring术语中的bean）组成。即使最简单的应用也具有多个对象，它们相互协作呈现给给端用户一个连续的应用程序。下一部分解释如何从定义大量的独立bean定义，到实现一个完整的应用。这些对象如何协作达到这个目标</p>
<h3 id="7-4-1-Dependency-Injection"><a href="#7-4-1-Dependency-Injection" class="headerlink" title="7.4.1 Dependency Injection"></a>7.4.1 Dependency Injection</h3><blockquote>
<p><em>Dependency injection</em> (DI) is a process whereby objects define their dependencies, that is, the other objects they work with, only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then <em>injects</em> those dependencies when it creates the bean. This process is fundamentally the inverse, hence the name <em>Inversion of Control</em> (IoC), of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes, or the <em>Service Locator</em> pattern.</p>
</blockquote>
<p><code>Dependency Injection</code>是一个对象定义其依赖项的过程，也就是说，对象只通过构造函数参数、工厂方法的参数或对象实例构造或从工厂方法返回后在对象实例上设置的属性来定义它们所使用的其他对象。 然后容器在创建bean的时候注入那些依赖项。这个过程本质上是相反的，因此名为“控制反转”，它通过直接构造类或使用诸如“服务定位器”模式之类的机制来控制其依赖项的实例化或位置。</p>
<blockquote>
<p>Code is cleaner with the DI principle and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies, and does not know the location or class of the dependencies. As such, your classes become easier to test, in particular when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests.</p>
</blockquote>
<p>使用DI原则，代码更干净，并且当提供给对象依赖项时，解耦更有效。对象不去查找其依赖项，且不知道依赖的位置或者类。这样，你的类变得易测试，特别是当依赖项依赖于接口或者抽象类时，允许在单元测试中使用stub和mock实现。</p>
<blockquote>
<p>DI exists in two major variants, <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-constructor-injection" target="_blank" rel="noopener">Constructor-based dependency injection</a> and <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-setter-injection" target="_blank" rel="noopener">Setter-based dependency injection</a>.                    n.  变体;变种;变化形式</p>
</blockquote>
<h4 id="Constructor-based-dependency-injection"><a href="#Constructor-based-dependency-injection" class="headerlink" title="Constructor-based dependency injection"></a>Constructor-based dependency injection</h4><p>基于构造方法的DI</p>
<blockquote>
<p><em>Constructor-based</em> DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a <code>static</code> factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a <code>static</code> factory method similarly. The following example shows a class that can only be dependency-injected with constructor injection. Notice that there is nothing <em>special</em> about this class, it is a POJO that has no dependencies on container specific interfaces, base classes or annotations. </p>
</blockquote>
<p>基于构造方法的DI，通过容器调用构造方法来完成，构造方法含有一些参数，每个参数代表一个依赖。调用带有特定参数的静态工厂方法构建bean几乎相同， 本次讨论同等对待构造函数和静态工厂方法的参数。下面例子表明一个类，只能使用构造方法来进行构造注入，并无特殊。注意，该类并无特别，它是一个pojo，不依赖于容器特定的接口，基类或者注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on a MovieFinder</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// a constructor so that the Spring container can inject a MovieFinder</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h5 id="Constructor-argument-resolution"><a href="#Constructor-argument-resolution" class="headerlink" title="Constructor argument resolution"></a>Constructor argument resolution</h5><p>构造参数解析</p>
<blockquote>
<p>Constructor argument resolution matching occurs using the argument’s type. If no potential ambiguity exists in the constructor arguments of a bean definition, then the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated. Consider the following class: </p>
</blockquote>
<p><strong>构造函数参数解析匹配使用参数的类型进行</strong>。 如果Bean定义的构造函数参数中不存在任何歧义，则在实例化Bean时，在Bean定义中定义构造函数参数的顺序就是将这些参数提供给适当的构造函数的顺序。 考虑以下类别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> x.y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Foo</span><span class="params">(Bar bar, Baz baz)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>No potential ambiguity exists, assuming that Bar and Baz classes are not related by inheritance. Thus the following configuration works fine, and you do not need to specify the constructor argument indexes and/or types explicitly in the <constructor-arg/> element.</p>
</blockquote>
<p>没有潜在的歧义存在，假设<code>Bar</code>和<code>Baz</code>都是与继承不相关的类。因此，下面的配置会工作正常，且你不需要通过<code>&lt;consturctor-arg/&gt;</code>元素来显示指定构造方法参数的index或者type，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span>  // 如果参数类型不存在歧义，已经确定，这里的顺序可以任意调换</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example). When a simple type is used, such as <code>true</code>, Spring cannot determine the type of the value, and so cannot match by type without help. Consider the following class: </p>
</blockquote>
<p>当引用另一个bean时，类型是已知的，并且可以匹配（与前面的示例一样）。 当使用简单类型（例如true）时，Spring无法确定值的类型，因此在没有帮助的情况下无法按类型进行匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBeanOne</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String ultimateAnswer;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBeanOne</span><span class="params">(<span class="keyword">int</span> year, String ultimateAnswer)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.year = year;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"ExampleBeanOne&#123;"</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="string">"year="</span> + year +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="string">", ultimateAnswer='"</span> + ultimateAnswer + <span class="string">'\''</span> +</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="string">'&#125;'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>In the preceding scenario, the container <em>can</em> use type matching with simple types if you explicitly specify the type of the constructor argument using the <code>type</code> attribute. For example:</p>
</blockquote>
<p>在上述场景中，对于简单类型，容器可以使用类型匹配。如果你使用了<code>type</code>属性显示指定了构造方法参数的类型。例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Use the <code>index</code> attribute to specify explicitly the index of constructor arguments. For example:</p>
</blockquote>
<p>使用<code>index</code>属性显示指定构造方法参数的index，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type. Note that the <em>index is 0 based</em>.</p>
</blockquote>
<p>除了解决多个简单值的歧义性之外，指定索引还可以解决歧义，当构造函数具有两个相同类型的参数。 请注意，<em>索引是基于0的</em>。</p>
<blockquote>
<p>You can also use the constructor parameter name for value disambiguation:</p>
</blockquote>
<p>您还可以使用构造函数参数名称来消除歧义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ultimateAnswer"</span> <span class="attr">value</span>=<span class="string">"42"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Keep in mind that to make this work out of the box your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you can’t compile your code with debug flag (or don’t want to) you can use <a href="https://download.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html" target="_blank" rel="noopener">@ConstructorProperties</a> JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows:</p>
</blockquote>
<p> 记住：为了使它能够开箱即用，必须启用debug flag选项来编译你的代码，以至Spring可以从构造方法中检索参数名。否则，你可以使用JDK注解 <code>@ConstructorProperties</code>来显示命名构造方法参数。样例如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> examples;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Fields omitted</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@ConstructorProperties</span>(&#123;<span class="string">"years"</span>, <span class="string">"ultimateAnswer"</span>&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(<span class="keyword">int</span> years, String ultimateAnswer)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.years = years;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.ultimateAnswer = ultimateAnswer;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<ol>
<li><p>如果<constructor-arg/>的顺序和实例中构造方法中的参数一致，那么可以完成实例化，即使不指定类型</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBeanOne"</span> <span class="attr">class</span>=<span class="string">"com.bgw.sample2.ExampleBeanOne"</span> &gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"abc"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>
</li>
<li><p>如果顺序不一致，无法完成实例化</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBeanOne"</span> <span class="attr">class</span>=<span class="string">"com.bgw.sample2.ExampleBeanOne"</span> &gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"abc"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"100"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>
</li>
<li><p>如果顺序不一致，指定了实例化的辅助信息，比如类型，name，参数位置，也可以完成实例化</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBeanOne"</span> <span class="attr">class</span>=<span class="string">"com.bgw.sample2.ExampleBeanOne"</span> &gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"abc"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"2019"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBeanOne"</span> <span class="attr">class</span>=<span class="string">"com.bgw.sample2.ExampleBeanOne"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"2019"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"abc"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"com.bgw.sample2.ExampleBeanOne"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"year"</span> <span class="attr">value</span>=<span class="string">"2019"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"utilmateAnswer"</span> <span class="attr">value</span>=<span class="string">"abc"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="Setter-based-dependency-injection"><a href="#Setter-based-dependency-injection" class="headerlink" title="Setter-based dependency injection"></a>Setter-based dependency injection</h4><p>基于setter的DI</p>
<blockquote>
<p><em>Setter-based</em> DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or no-argument <code>static</code> factory method to instantiate your bean.</p>
</blockquote>
<p>基于setter的DI是容器通过调用无参构造方法或者无参静态工厂方法实例化bean后，调用bean上的setter方法来完成的</p>
<blockquote>
<p>The following example shows a class that can only be dependency-injected using pure setter injection. This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces, base classes or annotations.</p>
</blockquote>
<p>下述例子表明了一个类仅可以通过纯setter注入来实现DI。这个类是一个常规类。是一个pojo，没有依赖与容器特定接口，基类或者注解。</p>
<p>setter方法注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// the SimpleMovieLister has a dependency on the MovieFinder</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// a setter method so that the Spring container can inject a MovieFinder</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// business logic that actually uses the injected MovieFinder is omitted...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>ApplicationContext</code> supports constructor-based and setter-based DI for the beans it manages. It also supports setter-based DI after some dependencies have already been injected through the constructor approach. You configure the dependencies in the form of a <code>BeanDefinition</code>, which you use in conjunction with <code>PropertyEditor</code> instances to convert properties from one format to another. However, most Spring users do not work with these classes directly (i.e., programmatically) but rather with XML <code>bean</code> definitions, annotated components (i.e., classes annotated with <code>@Component</code>, <code>@Controller</code>, etc.), or <code>@Bean</code> methods in Java-based <code>@Configuration</code> classes. These sources are then converted internally into instances of <code>BeanDefinition</code> and used to load an entire Spring IoC container instance.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">in conjunction with  与...一起</span></pre></td></tr></table></figure>

<p><code>ApplicationContext</code>对于其管理的bean支持构造方法DI和setterDI。在通过构造函数方法注入了某些依赖项之后，它还支持基于setter的DI。以<code>BeanDefinition</code>的形式来配置依赖，与<code>PropertyEditor</code>实例一起，转换properties从一种形式到另一种。但是，大多Spring用户并不直接使用这些类（比如，程序化），而是使用XML bean定义，注解组件（比如使用<code>@Component @Controller</code>等注解的类），或者基于java代码配置的<code>@Configuration</code>类上的注解<code>@Bean</code>方法 。这些资源内部会被转换为<code>BeanDefinition</code>的实例，并用来加载一个完整的Spring IoC容器实例。</p>
<blockquote>
<p><strong>Constructor-based or setter-based DI?</strong></p>
<p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the @Required annotation on a setter method can be used to make the property a required dependency.</p>
<p><strong>The Spring team generally advocates constructor injection as it enables one to implement application components as immutable objects and to ensure that required dependencies are not null. Furthermore constructor-injected components are always returned to client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns.</strong></p>
<p>Spring团队通常提倡构造函数注入，因为它使人们能够将应用程序组件实现为不可变对象，并确保所需的依赖项不为null。 此外，注入构造函数的组件总是以完全初始化的状态返回到客户端（调用）代码。 附带说明一下，大量的构造函数参数是一种不好的代码味，这表明该类可能承担了太多的职责，应进行重构以更好地解决关注点分离问题。</p>
<p><strong>Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through JMX MBeans is therefore a compelling use case for setter injection.</strong></p>
<p>Setter注入主要应仅用于可以在类中分配合理的默认值的可选依赖项。 否则，必须在代码使用依赖项的任何地方执行非空检查。 setter注入的一个好处是，setter方法使该类的对象在以后可以重新配置或重新注入。 因此，通过JMX MBean进行管理是用于setter注入的引人注目的用例。</p>
<p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI.</p>
<p>使用DI风格最适合特定的类。有时候，当处理没有源代码的第三方类时，DI为你做出选择。例如，如果一个第三方的类没有提供setter方法，那么构造函数注入可能是DI的唯一可用形式。</p>
</blockquote>
<h4 id="Dependency-resolution-process"><a href="#Dependency-resolution-process" class="headerlink" title="Dependency resolution process"></a>Dependency resolution process</h4><p>依赖解析过程</p>
<blockquote>
<p>The container performs bean dependency resolution as follows:</p>
<ul>
<li>The <code>ApplicationContext</code> is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified via XML, Java code, or annotations.</li>
<li>For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method if you are using that instead of a normal constructor. These dependencies are provided to the bean, <em>when the bean is actually created</em>.</li>
<li>Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container.</li>
<li>Each property or constructor argument which is a value is converted from its specified format to the actual type of that property or constructor argument. By default Spring can convert a value supplied in string format to all built-in types, such as <code>int</code>, <code>long</code>, <code>String</code>, <code>boolean</code>, etc.</li>
</ul>
</blockquote>
<p> 容器按照如下执行bean 依赖解析：</p>
<ul>
<li><p>将使用描述所有Bean的配置元数据创建并初始化<code>ApplicationContext</code>。 可以通过XML，Java代码或注释指定配置元数据。</p>
</li>
<li><p>对于每个bean，其依赖项都以属性，构造函数参数或static-factory方法的参数（如果您使用的是常规构造函数）的形式表示。 这些依赖项是在“实际创建” Bean时提供给Bean的。</p>
</li>
<li><p>每个属性或构造函数参数都是要设置的值的实际定义，或者是对容器中另一个bean的引用。</p>
</li>
<li><p>每个作为值的属性或构造函数参数都将从其指定的格式转换为该属性或构造函数参数的实际类型。 默认情况下，Spring可以将提供的字符串格式的值转换为所有内置类型，例如<code>int</code>，<code>long</code>，<code>String</code>，<code>boolean</code>等。</p>
</li>
</ul>
<blockquote>
<p>The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean <em>is actually created</em>. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="noopener">Section 7.5, “Bean scopes”</a>. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean’s dependencies and its dependencies’ dependencies (and so on) are created and assigned. Note that resolution mismatches among those dependencies may show up late, i.e. on first creation of the affected bean.</p>
</blockquote>
<p>在创建容器时，spring容器会验证每个bean的配置。 但是，在实际创建bean之前这些bean属性不会被设置。当容器创建时，将创建具有单例作用域并设置为预先实例化（默认）的bean。(也就是说单例bean不是延迟加载 ？ )否则，仅在请求（使用）时创建。当创建和分配bean的依赖和依赖的依赖（以此类推）时，bean的创建可能会创建一个bean图。注意，解决这些依赖间不匹配的时机可能会较晚，比如在首次创建受影响的bean时</p>
<blockquote>
<p><strong>Circular dependencies 循环依赖</strong> </p>
<p>If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.</p>
<p>如果您主要使用构造函数注入，则可能会创建无法解决的循环依赖方案。</p>
<p>For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a <code>BeanCurrentlyInCreationException</code>.</p>
<p>运行时检测循环引用，抛出BeanCurrentlyInCreationException异常</p>
<p>One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection.</p>
<p>一种可能的解决方案是修改某些类的源代码，这些类的源代码由 setter 注入而不是构造函数来注入。 或者，避免构造函数注入，而仅使用 setter 注入。 换句话说，尽管不建议这样做，但是您可以使用 setter 注入来配置循环依赖项。</p>
<p>Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken/egg scenario).</p>
<p>与典型情况（没有循环依赖关系）不同，bean A和 bean B之间的循环依赖关系迫使其中一个  bean 在完全初始化之前被注入另一个 bean（ 经典的 chicken / egg 场景 ）</p>
</blockquote>
<blockquote>
<p>It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time. Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container which has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies. For example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why <code>ApplicationContext</code> implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the <code>ApplicationContext</code> is created, not later. You can still override this default behavior so that singleton beans will lazy-initialize, rather than be pre-instantiated. </p>
</blockquote>
<p>Spring在容器加载时检测配置问题，比如对不存在bean的引用和循环依赖。在实际创建bean时，Spring尽可能晚的设置属性和解析依赖。这意味着如果创建的对象或是它的依赖存在问题，Spring容器可能会正确地加载并在请求对象时生成一个异常。例如，由于缺少或者无效属性，bean则抛出异常。某些配置问题的这种潜在延迟可见性是默认情况下<code>ApplicationContext</code>实现预先实例化单例bean的原因。在实际需要这些bean之前，先花一些时间和内存来创建它们，你会在创建<code>ApplicationContext</code>时发现配置问题，而不是稍后。你仍然可以覆盖这个默认行为，以便单例bean延迟初始化而不是预先初始化。</p>
<blockquote>
<p>If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a configured init method or the InitializingBean callback method) are invoked.</p>
</blockquote>
<p>如果不存在循环依赖，当一个或多个协作bean被注入到依赖bean中时，每个协作的bean在被注入到依赖bean之前都已完全配置完毕。这意味着如果beanA依赖beanB，Spring IOC容器在调用bean的setter方法之前已完全配置好beanB。换句话说，实例化该bean（如果不是预先实例化的单例），则设置其依赖关系，并调用相关的生命周期方法（例如配置的init方法或InitializingBean回调方法）</p>
<h4 id="Examples-of-dependency-injection"><a href="#Examples-of-dependency-injection" class="headerlink" title="Examples of dependency injection"></a>Examples of dependency injection</h4><blockquote>
<p>The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- setter injection using the nested ref element --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- setter injection using the neater ref attribute --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanOne</span><span class="params">(AnotherBean beanOne)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.beanOne = beanOne;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanTwo</span><span class="params">(YetAnotherBean beanTwo)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.beanTwo = beanTwo;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntegerProperty</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.i = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>In the preceding example, setters are declared to match against the properties specified in the XML file. The following example uses constructor-based DI:</p>
</blockquote>
<p>上述例子中，声明setter方法匹配指定在xml文件中的属性。下面的例子使用构造方法注入：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- constructor injection using the nested ref element --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- constructor injection using the neater ref attribute --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> AnotherBean beanOne;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> YetAnotherBean beanTwo;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExampleBean</span><span class="params">(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.beanOne = anotherBean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.beanTwo = yetAnotherBean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.i = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The constructor arguments specified in the bean definition will be used as arguments to the constructor of the <code>ExampleBean</code>.</p>
</blockquote>
<p>bean定义中指定的构造方法参数：三个<code>&lt;constructor-arg /&gt;</code>, 将被作为<code>ExampleBean</code>构造方法的参数</p>
<blockquote>
<p>Now consider a variant of this example, where instead of using a constructor, Spring is told to call a <code>static</code> factory method to return an instance of the object:</p>
</blockquote>
<p>现在考虑下这个例子的变种，不用构造方法，Spring被告知调用静态工厂方法返回对象实例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"anotherExampleBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"yetAnotherBean"</span> <span class="attr">class</span>=<span class="string">"examples.YetAnotherBean"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// a private constructor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ExampleBean</span><span class="params">(...)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// a static factory method; the arguments to this method can be</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// considered the dependencies of the bean that is returned,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// regardless of how those arguments are actually used.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExampleBean <span class="title">createInstance</span> <span class="params">(</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, <span class="keyword">int</span> i)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        ExampleBean eb = <span class="keyword">new</span> ExampleBean (...);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// some other operations...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> eb;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Arguments to the <code>static</code> factory method are supplied via <code>&lt;constructor-arg/&gt;</code> elements, exactly the same as if a constructor had actually been used. The type of the class being returned by the factory method does not have to be of the same type as the class that contains the <code>static</code> factory method, although in this example it is. An instance (non-static) factory method would be used in an essentially identical fashion (aside from the use of the <code>factory-bean</code> attribute instead of the <code>class</code> attribute), so details will not be discussed here.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">essentially adv.  根本上，本质上； 大体上，基本上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">aside from 除了</span></pre></td></tr></table></figure>



<p>静态工厂方法的参数是通过<code>&lt;constructor-arg/&gt;</code>元素提供的，和实际使用构造方法完全相同。静态工厂方法返回类的类型不一定和包含该静态工厂方法类的类型相同，尽管在这个例子中相同。实例工厂方法本质上会以基本相同的方式使用（除了使用<code>factory-bean</code>属性而不是<code>class</code>属性）。细节不在这里讨论。</p>
<h3 id="7-4-2-Dependencies-and-configuration-in-detail"><a href="#7-4-2-Dependencies-and-configuration-in-detail" class="headerlink" title="7.4.2 Dependencies and configuration in detail"></a>7.4.2 Dependencies and configuration in detail</h3><blockquote>
<p>As mentioned in the previous section, you can define bean properties and constructor arguments as references to other managed beans (collaborators), or as values defined inline. Spring’s XML-based configuration metadata supports sub-element types within its<code>&lt;property/&gt;</code>and<code>&lt;constructor-arg/&gt;</code> elements for this purpose.</p>
</blockquote>
<p>如上一节所述，可以定义bean的属性和构造方法参数，作为对其他管理bean（协作者）的引用， 也可定义为内联定义的值。Spring基于XML的配置元数据为此目的在其<code>&lt;property /&gt;</code>和<code>&lt;constructor-arg /&gt;</code>元素内支持子元素类型。</p>
<h4 id="Straight-values-primitives-Strings-and-so-on"><a href="#Straight-values-primitives-Strings-and-so-on" class="headerlink" title="Straight values (primitives, Strings, and so on)"></a>Straight values (primitives, Strings, and so on)</h4><p>直接值（基本数据类型，字符串等等）</p>
<blockquote>
<p>The <code>value</code> attribute of the <code>property</code> element specifies a property or constructor argument as a human-readable string representation. Spring’s <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#core-convert-ConversionService-API" target="_blank" rel="noopener">conversion service</a> is used to convert these values from a <code>String</code> to the actual type of the property or argument.</p>
</blockquote>
<p><code>property</code>元素的<code>value</code>属性将属性或者构造方法参数指定为人类可读的字符串表示形式。Spring的转换服务用于将这些值从字符串转换为属性或者参数的实际类型</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- results in a setDriverClassName(String) call --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"masterkaoli"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The following example uses the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-p-namespace" target="_blank" rel="noopener">p-namespace</a> for even more succinct XML configuration.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">succinct adj. 简洁的，简明的，简要的</span></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">    https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">p:driverClassName</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">p:url</span>=<span class="string">"jdbc:mysql://localhost:3306/mydb"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">p:username</span>=<span class="string">"root"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">p:password</span>=<span class="string">"masterkaoli"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The preceding XML is more succinct; however, typos are discovered at runtime rather than design time, unless you use an IDE such as <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a> or the <a href="https://spring.io/tools/sts" target="_blank" rel="noopener">Spring Tool Suite</a> (STS) that support automatic property completion when you create bean definitions. Such IDE assistance is highly recommended.</p>
</blockquote>
<p>上述xml相当简洁。但是拼写错误会在运行时被发现而不是设计时，当你创建bean定义时，除非你使用比如IDEA或者SpringToolSuite类似的IDE，它们支持属性的自动补全。强烈推荐使用</p>
<blockquote>
<p>You can also configure a <code>java.util.Properties</code> instance as:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mappings"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- typed as a java.util.Properties --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            jdbc.driver.className=com.mysql.jdbc.Driver</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            jdbc.url=jdbc:mysql://localhost:3306/mydb</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The Spring container converts the text inside the <code>&lt;value/&gt;</code> element into a <code>java.util.Properties</code> instance by using the JavaBeans <code>PropertyEditor</code> mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <code>&lt;value/&gt;</code> element over the <code>&lt;value&gt;</code> attribute style.</p>
</blockquote>
<p>Spring容器通过使用javaBean<code>PropertyEditor</code>机制将<code>&lt;value/&gt;</code>元素里的文本转换为<code>java.util.Properties</code>实例。这是一个不错的捷径，并且是Spring团队偏爱使用嵌套<code>&lt;value/&gt;</code>元素而不使用<code>&lt;value&gt;</code>属性样式的几个地方之一</p>
<h5 id="The-idref-element"><a href="#The-idref-element" class="headerlink" title="The idref element"></a>The idref element</h5><blockquote>
<p>The <code>idref</code> element is simply an error-proof way to pass the id (string value - not a reference) of another bean in the container to a <code>&lt;constructor-arg/&gt;</code>or <code>&lt;property/&gt;</code> element.</p>
</blockquote>
<p><code>idref</code>仅仅是一种将容器中另一个bean的id（字符串值，不是引用）传递给<code>&lt;constructor-arg/&gt;</code>和<code>&lt;property/&gt;</code>元素的防错方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theClientBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">idref</span> <span class="attr">bean</span>=<span class="string">"theTargetBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The above bean definition snippet is <em>exactly</em> equivalent (at runtime) to the following snippet:</p>
</blockquote>
<p>上边bean定义的片段和下边片段完全等价（运行时）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"theTargetBean"</span> <span class="attr">class</span>=<span class="string">"..."</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"client"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetName"</span> <span class="attr">value</span>=<span class="string">"theTargetBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The first form is preferable to the second, because using the <code>idref</code> tag allows the container to validate <em>at deployment time</em> that the referenced, named bean actually exists. In the second variation, no validation is performed on the value that is passed to the <code>targetName</code> property of the <code>client</code> bean. Typos are only discovered (with most likely fatal results) when the <code>client</code> bean is actually instantiated. If the <code>client</code> bean is a <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="noopener">prototype</a> bean, this typo and the resulting exception may only be discovered long after the container is deployed.</p>
</blockquote>
<p>第一种形式优于第二种，应为使用<code>idref</code>标签允许容器在部署时验证所引用的命名bean是否实际存在。在第二个变体中，不对传递给<code>client</code> bean的<code>targetName</code>属性的值进行验证。当<code>client</code>bean实际实例化时，错误才被发现（可能导致致命错误）。如果<code>client</code>bean是原型类型的bean，这个错误和导致的异常可能容器部署后很长时间才被发现。</p>
<blockquote>
<p>The <code>local</code> attribute on the <code>idref</code> element is no longer supported in the 4.0 beans xsd since it does not provide value over a regular <code>bean</code> reference anymore. Simply change your existing <code>idref local</code> references to <code>idref bean</code> when upgrading to the 4.0 schema.</p>
</blockquote>
<p>4.0的bean xsd不在支持<code>idref</code>元素的<code>local</code>属性，因为它不再提供常规bean引用的值。升级到4.0模式时，只需将现有的<code>idref local</code>引用更改为<code>idref bean</code>即可。</p>
<blockquote>
<p>A common place (at least in versions earlier than Spring 2.0) where the <code>&lt;idref/&gt;</code> element brings value is in the configuration of <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#aop-pfb-1" target="_blank" rel="noopener">AOP interceptors</a> in a <code>ProxyFactoryBean</code> bean definition. Using <code>&lt;idref/&gt;</code> elements when you specify the interceptor names prevents you from misspelling an interceptor id.</p>
</blockquote>
<h4 id="References-to-other-beans-collaborators"><a href="#References-to-other-beans-collaborators" class="headerlink" title="References to other beans (collaborators)"></a>References to other beans (collaborators)</h4><p>引用其他bean</p>
<blockquote>
<p>The <code>ref</code> element is the final element inside a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code> definition element. Here you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property will be set, and it is initialized on demand as needed before the property is set. (If the collaborator is a singleton bean, it may be initialized already by the container.) All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the id/name of the other object through the <code>bean</code>, <code>local</code>, or <code>parent</code> attributes.</p>
</blockquote>
<p><code>ref</code>是<code>&lt;constructor-arg/&gt;</code>  或 <code>&lt;property/&gt;</code>定义元素里最后一个元素。此处，你设置指定bean的属性的值为容器管理的其他bean的引用（协作者）。这个引用bean是这个bean的依赖，它的属性将被设置。并且在属性设置之前按需初始化。（如果协作者是一个单例bean，它可能已经被容器初始化）。所有引用最终是对另一个对象的引用。范围和验证取决于你通过<code>bean</code>,<code>local</code>,<code>parent</code>属性是否指定了其他对象id或者name。</p>
<blockquote>
<p>Specifying the target bean through the <code>bean</code> attribute of the <code>&lt;ref/&gt;</code> tag is the most general form, and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the <code>bean</code> attribute may be the same as the <code>id</code> attribute of the target bean, or as one of the values in the <code>name</code> attribute of the target bean.</p>
</blockquote>
<p>根据<code>&lt;ref/&gt;</code>标签的<code>bean</code>属性指定目标bean是最常用的形式，并且在相同的容器中或者父容器中允许任何bean引用的创建，不管是不是相同的xml 文件。<code>bean</code>属性的值可能和目标bean<code>id</code>属性的值相同，或者作为目标bean<code>name</code>属性值中的一个。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"someBean"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"someBean"</span> <span class="attr">class</span>=<span class="string">"com.example.TargetBean"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Specifying the target bean through the <code>parent</code> attribute creates a reference to a bean that is in a parent container of the current container. The value of the <code>parent</code> attribute may be the same as either the <code>id</code> attribute of the target bean, or one of the values in the <code>name</code> attribute of the target bean, and the target bean must be in a parent container of the current one. You use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that will have the same name as the parent bean.</p>
</blockquote>
<p>在当前容器的父容器中，通过创建bean引用的<code>parent</code>属性，指定目标bean。<code>parent</code>属性的值可能和目标bean<code>id</code>属性的值一样或者是目标bean<code>name</code>属性值中的一个，并且目标bean必须在当前容器的父容器。当在层次结构的容器中，或者你想通过可能拥有和父bean相同的名称代理来包装父容器中现有的bean，。主要使用该bean的引用变量。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- in the parent context --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.SimpleAccountService"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- insert dependencies as required as here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- in the child (descendant) context --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">parent</span>=<span class="string">"accountService"</span>/&gt;</span> <span class="comment">&lt;!-- notice how we refer to the parent bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- insert other configuration and dependencies as required here --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<h4 id="Inner-beans"><a href="#Inner-beans" class="headerlink" title="Inner beans"></a>Inner beans</h4><p>内部bean</p>
<blockquote>
<p>A <code>&lt;bean/&gt;</code> element inside the<code>&lt;property/&gt;</code> or <code>&lt;constructor-arg/&gt;</code> elements defines a so-called inner bean.</p>
</blockquote>
<p><code>&lt;property/&gt;</code> 或者<code>&lt;constructor-arg/&gt;</code>元素内的<code>&lt;bean/&gt;</code>元素定义了所谓的内部bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"outer"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"target"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span> <span class="comment">&lt;!-- this is the inner bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>An inner bean definition does not require a defined id or name; if specified, the container does not use such a value as an identifier. The container also ignores the <code>scope</code> flag on creation: Inner beans are <em>always</em> anonymous and they are <em>always</em> created with the outer bean. It is <em>not</em> possible to inject inner beans into collaborating beans other than into the enclosing bean or to access them independently.</p>
</blockquote>
<p>内部bean定义不需要定义id或者name。若指定，容器不会使用以次标识的值。容器在创建bean时，也会忽略作用域标识：内部bean通常是匿明的并且通常随着外部bean创建。不能将内部bean注入到协作bean中，也不能注入到封闭的bean来独立地访问他们。</p>
<blockquote>
<p>As a corner case, it is possible to receive destruction callbacks from a custom scope, e.g. for a request-scoped inner bean contained within a singleton bean: The creation of the inner bean instance will be tied to its containing bean, but destruction callbacks allow it to participate in the request scope’s lifecycle. This is not a common scenario; inner beans typically simply share their containing bean’s scope.</p>
</blockquote>
<p>作为特殊情况，可以从自定义的作用域接收销毁回调，例如，request作用域的内部bean，它包含在单例bean内部：内部bean实例的创建与其包含的bean绑定到一起，但是销毁回调允许他参与request作用域的生命周期。这不是常见情况; 内部类bean通常指只共享其包含bean的作用域</p>
<h4 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h4><blockquote>
<p>In the <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;props/&gt;</code>elements, you set the properties and arguments of the Java Collection types List, Set, Map, and Properties, respectively.</p>
</blockquote>
<p>在<code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>,<code>&lt;map/&gt;</code>和 <code>&lt;props/&gt;</code>元素中，可以分别设置，List,Set,Map,Properties集合类型的属性和参数。 </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"moreComplexObject"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"development"</span>&gt;</span>development@example.org<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- results in a setSomeList(java.util.List) call --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someList"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>a list element followed by a reference<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- results in a setSomeMap(java.util.Map) call --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someMap"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"an entry"</span> <span class="attr">value</span>=<span class="string">"just some string"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span> =<span class="string">"a ref"</span> <span class="attr">value-ref</span>=<span class="string">"myDataSource"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"someSet"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>just some string<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myDataSource"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p><em>The value of a map key or value, or a set value, can also again be any of the following elements:</em></p>
</blockquote>
<p>map的key或value，set的value，也可是以下任意值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">bean | ref | idref | list | set | map | props | value | null</span></pre></td></tr></table></figure>

<h5 id="Collection-merging"><a href="#Collection-merging" class="headerlink" title="Collection merging"></a>Collection merging</h5><p>集合合并</p>
<blockquote>
<p>The Spring container also supports the merging of collections. An application developer can define a parent-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code>element, and have child-style <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> elements inherit and override values from the parent collection. That is, the child collection’s values are the result of merging the elements of the parent and child collections, with the child’s collection elements overriding values specified in the parent collection.</p>
</blockquote>
<p>Spring容器也支持集合合并。应用开发者可以定义父级风格的<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>,<code>&lt;set/&gt;</code>,<code>&lt;props/&gt;</code>的元素，也可以有子级风格的<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>,<code>&lt;set/&gt;</code>,<code>&lt;props/&gt;</code>，继承覆盖父集合的值。也就是说，子集合的值是父级元素和子集合合并的结果，子集合元素覆盖父集合中特定的值</p>
<blockquote>
<p><em>This section on merging discusses the parent-child bean mechanism. Readers unfamiliar with parent and child bean definitions may wish to read the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-child-bean-definitions" target="_blank" rel="noopener">relevant section</a> before continuing.</em></p>
<p>The following example demonstrates collection merging:</p>
</blockquote>
<p>合并部分讨论父子bean机制。不熟悉父子bean定义的读者，在继续前可能要去阅读相关部分</p>
<p>下面的例子演示了集合合并：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"parent"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"example.ComplexObject"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"administrator"</span>&gt;</span>administrator@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">parent</span>=<span class="string">"parent"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"adminEmails"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">&lt;!-- the merge is specified on the child collection definition --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">props</span> <span class="attr">merge</span>=<span class="string">"true"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"sales"</span>&gt;</span>sales@example.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"support"</span>&gt;</span>support@example.co.uk<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Notice the use of the <code>merge=true</code> attribute on the<code>&lt;props/&gt;</code> element of the <code>adminEmails</code> property of the child bean definition. When the <code>child</code> bean is resolved and instantiated by the container, the resulting instance has an <code>adminEmails</code> <code>Properties</code> collection that contains the result of the merging of the child’s <code>adminEmails</code> collection with the parent’s <code>adminEmails</code> collection.</p>
</blockquote>
<p>注意属性<code>adminEmails</code>的<code>&lt;props/&gt;</code>元素上<code>merge=true</code>属性的使用定义子bena。当子bean被容器解析实例化时，结果实例有一个<code>Properties</code>集合的<code>adminEmails</code>属性，该包含了父子集合<code>adminEmials</code>合并的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">administrator&#x3D;administrator@example.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">sales&#x3D;sales@example.com</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">support&#x3D;support@example.co.uk</span></pre></td></tr></table></figure>

<blockquote>
<p>The child <code>Properties</code> collection’s value set inherits all property elements from the parent <code>&lt;props/&gt;</code>, and the child’s value for the <code>support</code> value overrides the value in the parent collection.</p>
</blockquote>
<p>子bean中<code>Properties</code>集合的值继承自所有父<code>&lt;props/&gt;</code>的元素属性，子值也支持覆盖服父集合</p>
<blockquote>
<p> This merging behavior applies similarly to the<code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;set/&gt;</code> collection types. In the specific case of the <code>&lt;list/&gt;</code> element, the semantics associated with the <code>List</code> collection type, that is, the notion of an ordered collection of values, is maintained; the parent’s values precede all of the child list’s values. In the case of the <code>Map</code>, <code>Set</code>, and<code>Properties</code> collection types, no ordering exists. Hence no ordering semantics are in effect for the collection types that underlie the associated <code>Map</code>, <code>Set</code>, and <code>Properties</code> implementation types that the container uses internally.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">semantics n. 语义学</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">precede prep. 放生在...之前，先于</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">underlie v. 为...的起因，构成...的基础</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">hence adv. 因此由此所以</span></pre></td></tr></table></figure>

<p>合并行为类似适用于<code>&lt;list/&gt;</code>，<code>&lt;map/&gt;</code>和<code>&lt;set/&gt;</code>集合类型。在<code>&lt;list/&gt;</code>元素的特定情况下，将维护与<code>List</code>集合类型相关联的语义，即值的有序集合的概念；父级的值先于子级列表的所有值。对于<code>Map</code>,<code>Set</code>,<code>Properties</code>集合类型，不存在排序。因此，容器内部使用的关联<code>Map</code>,<code>Set</code>,<code>Properties</code>实现类型的集合类型，没有任何有效排序语义有效。</p>
<h5 id="Limitations-of-collection-merging"><a href="#Limitations-of-collection-merging" class="headerlink" title="Limitations of collection merging"></a>Limitations of collection merging</h5><p>集合合并限制</p>
<blockquote>
<p>You cannot merge different collection types (such as a <code>Map</code> and a <code>List</code>), and if you do attempt to do so an appropriate <code>Exception</code> is thrown. The <code>merge</code> attribute must be specified on the lower, inherited, child definition; specifying the <code>merge</code> attribute on a parent collection definition is redundant and will not result in the desired merging.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">appropriate adj. 合适的，适当的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">redundant adj. (人员因过剩)被解雇的，被裁的； 多余的，过剩的，不需要的</span></pre></td></tr></table></figure>

<p>不能合并不同的集合类型，例如<code>Map</code>和<code>List</code>, 如果尝试这么做会抛出相应的<code>Exception</code>。<code>merge</code>属性必须在更低的，继承的子bean定义中指定。在父级指定是多余的，不会导致任何期望的，想要的合并</p>
<h5 id="Strongly-typed-collection"><a href="#Strongly-typed-collection" class="headerlink" title="Strongly-typed collection"></a>Strongly-typed collection</h5><p>强类型集合</p>
<blockquote>
<p>With the introduction of generic types in Java 5, you can use strongly typed collections. That is, it is possible to declare a <code>Collection</code> type such that it can only contain <code>String</code> elements (for example). If you are using Spring to dependency-inject a strongly-typed <code>Collection</code> into a bean, you can take advantage of Spring’s type-conversion support such that the elements of your strongly-typed <code>Collection</code> instances are converted to the appropriate type prior to being added to the <code>Collection</code>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">take advantage of  利用</span></pre></td></tr></table></figure>

<p>随着Java5泛型的引入，你可以使用强类型集合。也就是说，可以声明一个仅包含字符串元素的集合类型。如果使用Spring将强类型集合依赖注入到bean，可以利用Spring对类型转换的支持，将强类型集合元素的实例转换为相应的之前被添加到集合的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Map&lt;String, Float&gt; accounts; <span class="comment">// 泛型支持，集合强类型</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(Map&lt;String, Float&gt; accounts)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.accounts = accounts;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"accounts"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"9.99"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"2.75"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"six"</span> <span class="attr">value</span>=<span class="string">"3.99"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>When the <code>accounts</code> property of the <code>foo</code> bean is prepared for injection, the generics information about the element type of the strongly-typed <code>Map</code> is available by reflection. Thus Spring’s type conversion infrastructure recognizes the various value elements as being of type <code>Float</code>, and the string values <code>9.99, 2.75</code>, and <code>3.99</code> are converted into an actual <code>Float</code> type.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">generic adj. 一般的，通用的 n. 泛型</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">recognize... as...</span></pre></td></tr></table></figure>

<p>当id为foo的bean的accounts属性准备注入时，可以通过反射获取有关强类型<code>Map</code>的泛型信息.因此，Spring类型转换结构认为各个值为<code>Float</code>类型，然后字符串的值被转换为实际的<code>Float</code>类型</p>
<h4 id="Null-and-empty-string-values"><a href="#Null-and-empty-string-values" class="headerlink" title="Null and empty string values"></a>Null and empty string values</h4><p>null和空字符串值</p>
<blockquote>
<p>Spring treats empty arguments for properties and the like as empty <code>Strings</code>. The following XML-based configuration metadata snippet sets the email property to the empty <code>String</code> value (“”).</p>
</blockquote>
<p>Spring把空的属性参数视为类似的空字符串。下面基于xml配置元数据的片段设置email属性为空字符串</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The preceding example is equivalent to the following Java code:</p>
</blockquote>
<p>等价于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="string">""</span>);</span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>&lt;null/&gt;</code> element handles <code>null</code> values. For example:</p>
</blockquote>
<p><code>&lt;null/&gt;</code>元素处理null值，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">exampleBean.setEmail(<span class="keyword">null</span>);</span></pre></td></tr></table></figure>

<h4 id="XML-shortcut-with-the-p-namespace"><a href="#XML-shortcut-with-the-p-namespace" class="headerlink" title="XML shortcut with the p-namespace"></a>XML shortcut with the p-namespace</h4><p>命名空间p xml 快捷方式</p>
<blockquote>
<p>The p-namespace enables you to use the <code>bean</code> element’s attributes, instead of nested <code>&lt;property/&gt;</code> elements, to describe your property values and/or collaborating beans.</p>
</blockquote>
<p>p命名空间可以让你使用bean元素的属性，而不是嵌套的<code>&lt;property/&gt;</code>元素，来描述属性的值或者协作bean</p>
<blockquote>
<p>Spring supports extensible configuration formats <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#xsd-configuration" target="_blank" rel="noopener">with namespaces</a>, which are based on an XML Schema definition. The <code>beans</code> configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring.</p>
</blockquote>
<p>使用基于xml schema定义的命名空间，Spring支持可扩展的配置格式。本章讨论以xml schema文档定义的bean配置格式。但是，p命名空间不定义在xsd文件中，而是仅存Spring核心中</p>
<blockquote>
<p>The following example shows two XML snippets that resolve to the same result: The first uses standard XML format and the second uses the p-namespace.</p>
</blockquote>
<p>下面的例子展示了两个xml片段，他们解析的结果相同，第一个使用标准的xml格式，第二是使用p-namespace</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"classic"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"p-namespace"</span> <span class="attr">class</span>=<span class="string">"com.example.ExampleBean"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">p:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The example shows an attribute in the p-namespace called email in the bean definition. This tells Spring to include a property declaration. As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name.</p>
</blockquote>
<p>例子中展示了bean定义中的称之为email的p-namespace。告诉Spring这包含一个属性的声明。如之前所述，p-namespace没有schema定义，因此你能将attribute name 设置为 property name</p>
<blockquote>
<p>This next example includes two more bean definitions that both have a reference to another bean:</p>
</blockquote>
<p>下个例子包含了多于两个的bean定义，其中两个引用其他bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-classic"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"John Doe"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"spouse"</span> <span class="attr">ref</span>=<span class="string">"jane"</span>/&gt;</span>                  spouse n. 配偶</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"john-modern"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"com.example.Person"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">p:name</span>=<span class="string">"John Doe"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">p:spouse-ref</span>=<span class="string">"jane"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"jane"</span> <span class="attr">class</span>=<span class="string">"com.example.Person"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Jane Doe"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>As you can see, this example includes not only a property value using the p-namespace, but also uses a special format to declare property references. Whereas the first bean definition uses <code>&lt;property name=&quot;spouse&quot; ref=&quot;jane&quot;/&gt;</code> to create a reference from bean <code>john</code> to bean <code>jane</code>, the second bean definition uses <code>p:spouse-ref=&quot;jane&quot;</code> as an attribute to do the exact same thing. In this case <code>spouse</code> is the property name, whereas the <code>-ref</code> part indicates that this is not a straight value but rather a reference to another bean.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">whereas conj. 但是，然而</span></pre></td></tr></table></figure>

<p>如你看到的，这个例子不仅包含使用p-namespace的属性值，还有使用特定格式声明的属性引用。但是第一个bean定义使用<code>&lt;property/&gt;</code>来创建从bean john到bean jane的引用，第二个bean定义使用了<code>p:spouse-ref=&quot;jane&quot;</code>作为属性来做完全相同的事情。这个例子中，<code>spouse</code>为一个属性名称，因此<code>-ref</code>部分表示这不是一个直接值而是对应其他bean的引用。</p>
<blockquote>
<p>The p-namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in <code>Ref</code>, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members, to avoid producing XML documents that use all three approaches at the same time.                       clash with 与…冲突</p>
</blockquote>
<p>p-namespace不如标准的xml格式灵活。例如，声明属性引用的格式与以“ Ref”结尾的属性发生冲突，而标准XML格式则没有。我们建议您谨慎选择该方法，并与团队成员进行交流，以免产生同时使用这三种方法的XML文档。</p>
<h4 id="XML-shortcut-with-the-c-namespace"><a href="#XML-shortcut-with-the-c-namespace" class="headerlink" title="XML shortcut with the c-namespace"></a>XML shortcut with the c-namespace</h4><blockquote>
<p>Similar to the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-p-namespace" target="_blank" rel="noopener">the section called “XML shortcut with the p-namespace”</a>, the <em>c-namespace</em>, newly introduced in Spring 3.1, allows usage of inlined attributes for configuring the constructor arguments rather then nested <code>constructor-arg</code> elements.</p>
</blockquote>
<p>和<code>XML shortcut with the p-namespace</code>类似，c-namespace，Spring3.1引入，允许使用内联属性来配置构造方法，而不是使用<code>constructor-arg</code>元素</p>
<blockquote>
<p>Let’s review the examples from <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-constructor-injection" target="_blank" rel="noopener">the section called “Constructor-based dependency injection”</a> with the <code>c:</code> namespace:</p>
</blockquote>
<p>回顾构造方法注入的例子，使用<code>c:namespace</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"bar"</span> <span class="attr">class</span>=<span class="string">"x.y.Bar"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"baz"</span> <span class="attr">class</span>=<span class="string">"x.y.Baz"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- traditional declaration --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"bar"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"baz"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- c-namespace declaration --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:bar-ref</span>=<span class="string">"bar"</span> <span class="attr">c:baz-ref</span>=<span class="string">"baz"</span> <span class="attr">c:email</span>=<span class="string">"foo@bar.com"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>c:</code> namespace uses the same conventions as the <code>p:</code> one (trailing <code>-ref</code> for bean references) for setting the constructor arguments by their names. And just as well, it needs to be declared even though it is not defined in an XSD schema (but it exists inside the Spring core).</p>
</blockquote>
<p>c:namespace使用和p相同的约定（结尾使用-ref对bean引用），来设置构造方法参数，尽管没有定义在xsd schema中，使用时需要声明。</p>
<blockquote>
<p>For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), one can use fallback to the argument indexes:</p>
</blockquote>
<p>对于极少情况下无法使用构造方法参数名称的情况，可以降级到使用参数索引的方式。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- c-namespace index declaration --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"x.y.Foo"</span> <span class="attr">c:_0-ref</span>=<span class="string">"bar"</span> <span class="attr">c:_1-ref</span>=<span class="string">"baz"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Due to the XML grammar, the index notation requires the presence of the leading <code>_</code> as XML attribute names cannot start with a number (even though some IDE allow it).</p>
</blockquote>
<p>由于xml语法的原因，索引符号要前导<code>_</code>的存在，因为xml 属性不能以数字开头，尽管一些ide允许</p>
<blockquote>
<p>In practice, the constructor resolution <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-ctor-arguments-resolution" target="_blank" rel="noopener">mechanism</a> is quite efficient in matching arguments so unless one really needs to, we recommend using the name notation through-out your configuration.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">notation n.符号，标记</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">through-out adv. 自始至终，从头到尾</span></pre></td></tr></table></figure>



<p>实际上，构造函数解析机制在匹配参数方面相当有效，因此除非确实需要，否则我们建议使用整个配置过程中使用名称符号</p>
<h4 id="Compound-property-names"><a href="#Compound-property-names" class="headerlink" title="Compound property names"></a>Compound property names</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">compound n. 化合物，混合物； adj. 复合的混合的</span></pre></td></tr></table></figure>

<p>混合属性名称  compound </p>
<blockquote>
<p>You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not <code>null</code>. Consider the following bean definition.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">as long as  只要...</span></pre></td></tr></table></figure>

<p>设置bean属性时，可以使用复合属性名称或嵌套属性名称，只要路径中除最终属性名称以外的所有组成部分都不为null。 考虑以下bean定义。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"foo"</span> <span class="attr">class</span>=<span class="string">"foo.Bar"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fred.bob.sammy"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>foo</code> bean has a <code>fred</code> property, which has a <code>bob</code> property, which has a <code>sammy</code> property, and that final <code>sammy</code> property is being set to the value <code>123</code>. In order for this to work, the <code>fred</code> property of <code>foo</code>, and the <code>bob</code> property of <code>fred</code> must not be <code>null</code> after the bean is constructed, or a <code>NullPointerException</code> is thrown</p>
</blockquote>
<p>foo bean 有一个名为fred的属性，fred又有一个bob的属性，bob又有一个名为sammy的属性，则smmy属性最终被设置为123。为了使此能够正常工作，bean创建后，foo的fred属性和fred的bob属性必须不能为null，否则会抛出<code>NullPointerException</code></p>
<h3 id="7-4-3-Using-depends-on"><a href="#7-4-3-Using-depends-on" class="headerlink" title="7.4.3 Using depends-on"></a>7.4.3 Using depends-on</h3><blockquote>
<p>If a bean is a dependency of another that usually means that one bean is set as a property of another. Typically you accomplish this with the <code>&lt;ref/&gt;</code><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-ref-element" target="_blank" rel="noopener"> element</a> in XML-based configuration metadata. However, sometimes dependencies between beans are less direct; for example, a static initializer in a class needs to be triggered, such as database driver registration. The <code>depends-on</code> attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. The following example uses the <code>depends-on</code> attribute to express a dependency on a single bean:</p>
</blockquote>
<p>如果一个bean是另一个bean的依赖项，通常意味着一个bean被设置为另一个bean的属性。通常在基于xml的配置元数据中，可以通过<code>&lt;ref/&gt;</code>来完成。但是，又是bean之间的依赖很少直接的。例如，一个类中需要触发的静态初始化器，例如数据库驱动注册。<code>depends-on</code>属性可以在使用此元素的bean初始化之前显示地强制一个或多个bean的初始化。以下示例使用<code>depends-on</code>属性来表示对单个bean的依赖关系：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>To express a dependency on multiple beans, supply a list of bean names as the value of the <code>depends-on</code> attribute, with commas, whitespace and semicolons, used as valid delimiters:</p>
</blockquote>
<p>为了表示多个bean上的依赖，<code>depends-on</code>属性的值提供了bean名称的列表，该列表以逗号，空格，分号作为有效的分隔符：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"beanOne"</span> <span class="attr">class</span>=<span class="string">"ExampleBean"</span> <span class="attr">depends-on</span>=<span class="string">"manager,accountDao"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"manager"</span> <span class="attr">ref</span>=<span class="string">"manager"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"manager"</span> <span class="attr">class</span>=<span class="string">"ManagerBean"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">class</span>=<span class="string">"x.y.jdbc.JdbcAccountDao"</span> /&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>depends-on</code> attribute in the bean definition can specify both an initialization-time dependency and, in the case of <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a> beans only, a corresponding destruction-time dependency. Dependent beans that define a <code>depends-on</code> relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus <code>depends-on</code> can also control shutdown order.</p>
</blockquote>
<p>bean定义中的<code>depends-on</code>属性既可以指定初始化时的依赖关系，也可以在单例bean的情况下，指定相应销毁时依赖关系。给定bean定义的具有<code>depends-on</code>关系的依赖bean首先被销毁，然后在销毁给定的bean本身。因此<code>depends-on</code>也可以控制开闭顺序。</p>
<h3 id="7-4-4-Lazy-initialized-beans"><a href="#7-4-4-Lazy-initialized-beans" class="headerlink" title="7.4.4 Lazy-initialized beans"></a>7.4.4 Lazy-initialized beans</h3><blockquote>
<p>By default, <code>ApplicationContext</code> implementations eagerly create and configure all <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a> beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is <em>not</em> desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup.            as opposed to 相对于，相反</p>
</blockquote>
<p>默认情况下，<code>ApplicationContext</code>实现会在初始化过程中急于（急切地）创建和配置所有的单例bean。一般来说，这种预加载是可取的，因为数小时或者数天后，会立即发现配置或者周围环境中的错误。如果此行为不是预想的那样，你可以通过标记bean定义为延迟加载来防止单例bean的预初始化。延迟加载的bean告诉IoC容器当首次请求时而不是启动时创建bean实例</p>
<blockquote>
<p>In XML, this behavior is controlled by the <code>lazy-init</code> attribute on the <code>&lt;bean/&gt;</code> element; for example:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.ExpensiveToCreateBean"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"not.lazy"</span> <span class="attr">class</span>=<span class="string">"com.foo.AnotherBean"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>When the preceding configuration is consumed by an <code>ApplicationContext</code>, the bean named <code>lazy</code> is not eagerly pre-instantiated when the <code>ApplicationContext</code> is starting up, whereas the <code>not.lazy</code> bean is eagerly pre-instantiated.</p>
</blockquote>
<p>当前面的配置被<code>ApplicationContext</code>消耗时，当<code>ApplicationContext</code>启动时，不会急于预先实例化名为lazy的bean，而会急于实例化not.lazy的bean</p>
<blockquote>
<p>However, when a lazy-initialized bean is a dependency of a singleton bean that is <em>not</em> lazy-initialized, the <code>ApplicationContext</code> creates the lazy-initialized bean at startup, because it must satisfy the singleton’s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized.</p>
</blockquote>
<p>但是，当费延迟初始化单例bean的依赖是一个延迟初始化bean时，<code>ApplicationContext</code>会在启动时创建延迟初始化的bean，因为它必须满足单例的依赖。延迟初始化bean被注入到其他非延迟初始化单例bean中</p>
<blockquote>
<p>You can also control lazy-initialization at the container level by using the <code>default-lazy-init</code> attribute on the <code>&lt;bean/&gt;</code> element; for example:</p>
</blockquote>
<p>使用<code>&lt;bean/&gt;</code>元素上的<code>default-lazy-init</code>属性在容器级别也能控制延迟初始化</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- no beans will be pre-instantiated... --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="7-4-5-Autowiring-collaborators"><a href="#7-4-5-Autowiring-collaborators" class="headerlink" title="7.4.5 Autowiring collaborators"></a>7.4.5 Autowiring collaborators</h3><p>自动装配协作者</p>
<blockquote>
<p>The Spring container can <em>autowire</em> relationships between collaborating beans. You can allow Spring to resolve collaborators (other beans) automatically for your bean by inspecting the contents of the <code>ApplicationContext</code>. Autowiring has the following advantages:</p>
<ul>
<li>Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-child-bean-definitions" target="_blank" rel="noopener">discussed elsewhere in this chapter</a> are also valuable in this regard.)</li>
<li>Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable.</li>
</ul>
<p>When using XML-based configuration metadata <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#ftn.d5e2674" target="_blank" rel="noopener">[2]</a>, you specify autowire mode for a bean definition with the <code>autowire</code> attribute of the <code>&lt;bean/&gt;</code> element. The autowiring functionality has four modes. You specify autowiring <em>per</em> bean and thus can choose which ones to autowire.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">in this regard 在这方面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">evolve v. 进化，演变</span></pre></td></tr></table></figure>

<p>Spring容器可以自动装备协作bean之间的关联，可以通过检查<code>ApplicationContext</code>的内容允许Spring自动解析协作者（其他bean）。自动装配具有以下优势：</p>
<ul>
<li>自动装配极大地减少了指定属性或者构造函数参数的需要。（其他机制，例如bean模板在本章其他地方讨论过，在这方面也很有价值）</li>
<li>当对象演变发展时，自动装配可以更新配置。例如你需要给一个类添加依赖，依赖会自动满足不需要更改配置。因此，自动装配在开发时过程中特别有用，当代码变得更加稳定时不用担心切换到显示编写的选择。</li>
</ul>
<p>当使用基于XML的配置元数据，可以使用<code>&lt;bean/&gt;</code>元素的<code>autowire</code>属性指定bean定义的自动装配模式。自动装配功能具有四种模式，指定自动装备从而可以选择装配那些</p>
<p><strong>Table 7.2. Autowiring modes</strong></p>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Explanation</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>(Default) No autowiring. Bean references must be defined via a <code>ref</code> element. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.</td>
</tr>
<tr>
<td>byName</td>
<td>Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name, and it contains a <em>master</em> property (that is, it has a <em>setMaster(..)</em> method), Spring looks for a bean definition named <code>master</code>, and uses it to set the property.</td>
</tr>
<tr>
<td>byType</td>
<td>Allows a property to be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use <em>byType</em> autowiring for that bean. If there are no matching beans, nothing happens; the property is not set.</td>
</tr>
<tr>
<td>constructor</td>
<td>Analogous to <em>byType</em>, but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised.</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">to some extent 在某种程度上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">clarity n. (书、论点等的)清楚，清晰易懂，明晰；思路清晰;有条理</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">analogous adj. similar 相似的，类似的，可比拟的</span></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>no</td>
<td>默认，不自动装配。bean引用必须通过<code>ref</code>元素定义。较大部署不推荐修改默认配置，因为明确指定协作者可以提供更好的控制和清晰度。在某种程度上，它记录了系统的结构</td>
</tr>
<tr>
<td>byName</td>
<td>通过属性名称自动装配。Spring寻找与需要自动装配的属性同名的bean。例如，如果一个bean定义使用基于名称的自动装配，它包含一个名为<code>master</code>的属性，Spring寻找名为<code>master</code>的bean定义，并且用它来设置属性</td>
</tr>
<tr>
<td>byType</td>
<td>如果在容器中正好有一个属性类型的bean存在，允许这个属性自动装配。如果bean存在多余一个，抛出致命异常，表明你不能为那个bean使用基于类型的自动装配。如果没有匹配的bean，什么都不会发生；属性没有被设置</td>
</tr>
<tr>
<td>constructor</td>
<td>和基于类型的类似，但是应用于构造方法参数。如果容器中不存在确切的一个构造参数类型的bean，会引发致命错误</td>
</tr>
</tbody></table>
<blockquote>
<p>With <em>byType</em> or <em>constructor</em> autowiring mode, you can wire arrays and typed-collections. In such cases <em>all</em> autowire candidates within the container that match the expected type are provided to satisfy the dependency. You can autowire strongly-typed Maps if the expected key type is <code>String</code>. An autowired Maps values will consist of all bean instances that match the expected type, and the Maps keys will contain the corresponding bean names.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">corresponding adj. 相应的</span></pre></td></tr></table></figure>

<p>使用基于类型或者构造方法的自动装配，你可以装配数组和集合类型。在这样的例子中，容器中所有的装配候选bean，匹配期望的类型，以满足依赖。如果期望的key类型是<code>String</code>, 你可以自动装配强类型<code>Map</code>。一个自动装配Map值将由匹配预期类型的所有bean实例组成，并且Map key将包含相应的bean名称</p>
<blockquote>
<p>You can combine autowire behavior with dependency checking, which is performed after autowiring completes.</p>
</blockquote>
<p>你可以将要来检查和自动装配行为联合，装配完后执行依赖检查</p>
<h4 id="Limitations-and-disadvantages-of-autowiring"><a href="#Limitations-and-disadvantages-of-autowiring" class="headerlink" title="Limitations and disadvantages of autowiring"></a>Limitations and disadvantages of autowiring</h4><p>自动装配的局限性和缺点</p>
<blockquote>
<p>Autowiring works best when it is used consistently across a project. If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions.</p>
</blockquote>
<p>当整个项目中一致使用自动装配时，其效果最佳。如果通常不适用自动装配，使用它来自动装配一两个bean定义可能会使得开发者感到困惑</p>
<blockquote>
<p>Consider the limitations and disadvantages of autowiring:</p>
</blockquote>
<blockquote>
<ul>
<li>Explicit dependencies in <code>property</code> and <code>constructor-arg</code> settings always override autowiring. You cannot autowire so-called <em>simple</em> properties such as primitives, <code>Strings</code>, and <code>Classes</code> (and arrays of such simple properties). This limitation is by-design.</li>
<li>Autowiring is less exact than explicit wiring. Although, as noted in the above table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results, the relationships between your Spring-managed objects are no longer documented explicitly.</li>
<li>Wiring information may not be available to tools that may generate documentation from a Spring container.</li>
<li>Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired. For arrays, collections, or Maps, this is not necessarily a problem. However for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown.</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ambiguity n. 含糊不清，模棱两可，不明确；歧义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">arbitrarily adv. 武断地，任意地，主观地</span></pre></td></tr></table></figure>



<p>考虑自动装配的局限性和缺点：</p>
<ul>
<li>显示设置<code>property</code>和<code>constructor-arg</code>依赖通常会覆盖在动装配。不能自动装配所谓的简单类型比如，基本类型，<code>String</code>和<code>Class</code>(和这些简单属性的数组)，此设计是限制使然</li>
<li>自动装配不如显示设置精确。尽管如上表中提到的，Spring谨慎地避免在可能导致未知结果的歧义的相框下猜测，因此不再显示地记录Spring管理对象间的关联性</li>
<li>装配信息可能不适用于可能从Spring容器生成文档的工具。</li>
<li>容器内的多个bean定义可能与要自动装配的setter方法或构造函数参数指定的类型匹配。 对于数组，集合或地图，这不一定是问题。 但是，对于期望单个值的依赖项，不会任意解决此歧义。 如果没有唯一的bean定义可用，则会引发异常。</li>
</ul>
<blockquote>
<p>In the latter scenario, you have several options:</p>
<ul>
<li>Abandon autowiring in favor of explicit wiring.</li>
<li>Avoid autowiring for a bean definition by setting its <code>autowire-candidate</code> attributes to <code>false</code> as described in the next section.</li>
<li>Designate a single bean definition as the <em>primary</em> candidate by setting the <code>primary</code> attribute of its <code>&lt;bean/&gt;</code> element to <code>true</code>.</li>
<li>Implement the more fine-grained control available with annotation-based configuration, as described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-annotation-config" target="_blank" rel="noopener">Section 7.9, “Annotation-based container configuration”</a>.</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">designate v. 标示;把…定名为;称呼</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">fine-grained  细粒度的</span></pre></td></tr></table></figure>

<p>对于后者情况，有几个选择：</p>
<ul>
<li>禁止自动准备，支持显示装配</li>
<li>通过设置它的<code>autowire-candidate</code>属性为<code>false</code>，将在下一部分描述，避免为bean自动装配</li>
<li>通过设置<code>&lt;bean/&gt;</code>元素的<code>primary</code>属性为<code>true</code>，来标识一个单一的bean</li>
<li>通过基于注解的配置来实现更细粒度的控制</li>
</ul>
<h4 id="Excluding-a-bean-from-autowiring"><a href="#Excluding-a-bean-from-autowiring" class="headerlink" title="Excluding a bean from autowiring"></a>Excluding a bean from autowiring</h4><p>从自动装配中排除bean</p>
<blockquote>
<p>On a per-bean basis, you can exclude a bean from autowiring. In Spring’s XML format, set the <code>autowire-candidate</code> attribute of the <code>&lt;bean/&gt;</code> element to <code>false</code>; the container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-autowired-annotation" target="_blank" rel="noopener"><code>@Autowired</code></a>).</p>
</blockquote>
<p>在每个bean的基础上，你可以从自动装配中排除bean。在Spring的XML格式中，将<code>&lt;bean/&gt;</code>元素的<code>autowire-candidate</code>属性设置为<code>false</code>。容器使特定的bean定义不适用于自动装配基础结构（包括注释样式配置，例如<code>@Autowired</code>）。</p>
<blockquote>
<p>The <code>autowire-candidate</code> attribute is designed to only affect type-based autowiring. It does not affect explicit references by name, which will get resolved even if the specified bean is not marked as an autowire candidate. As a consequence, autowiring by name will nevertheless inject a bean if the name matches.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">is designed to 旨在...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">as a consequence</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">in consequence 结果，因此</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">nevertheless 然而不过</span></pre></td></tr></table></figure>

<p><code>autowire-candidate</code>属性旨在仅影响基于类型的自动装配。不影响通过名称的显示引用，即使指定的bean未被表示为自动装配候选者，也会被解析。因此如果名称匹配基于名称的自动装配仍将注入bean</p>
<blockquote>
<p>You can also limit autowire candidates based on pattern-matching against bean names. The top-level <code>&lt;beans/&gt;</code> element accepts one or more patterns within its <code>default-autowire-candidates</code> attribute. For example, to limit autowire candidate status to any bean whose name ends with <em>Repository,</em> provide a value of *Repository. To provide multiple patterns, define them in a comma-separated list. An explicit value of <code>true</code> or <code>false</code> for a bean definitions <code>autowire-candidate</code> attribute always takes precedence, and for such beans, the pattern matching rules do not apply.</p>
</blockquote>
<p>也可以通过bean名称的正则匹配来限制自动装配候选者。顶层的<code>&lt;beans/&gt;</code>元素的<code>default-autowire-candidates</code>属性接收一个或多个正则模式。例如，要将自动装配候选者状态限制为以<code>Repository</code>结尾的名称，使用模式<code>*Repository</code>。使用逗号分隔多个模式列表。Bean定义<code>autowire-candidate</code>属性的显式值<code>true</code>或<code>false</code>始终优先，而对于此类Bean，模式匹配规则不适用。</p>
<blockquote>
<p>These techniques are useful for beans that you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">rather 而非，而不是</span></pre></td></tr></table></figure>

<p>如果不想通过自动装备来实现bean注入到其他bean，这些技术是很有用的。并不意味着被排除的bean本身不能配置为使用自动装配。而是bean本身不是自动装配其他bean的候选者。</p>
<h3 id="7-4-6-Method-injection"><a href="#7-4-6-Method-injection" class="headerlink" title="7.4.6 Method injection"></a>7.4.6 Method injection</h3><blockquote>
<p>In most application scenarios, most beans in the container are <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton" target="_blank" rel="noopener">singletons</a>. When a singleton bean needs to collaborate with another singleton bean, or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container only creates the singleton bean A once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.</p>
</blockquote>
<p>在大部分应用场景中，容器中的大部分bean都是单例的。当一个单例bean需要和其他单例bean协作时，或者非单例bean需要协作其他非单例bean时，通常通过将一个bean定义为其他bean的属性来处理依赖。当bean的生命周期不同会引发问题。假设单例bean A 需要使用非单例beanB（原型），可能在A的每个方法上都会调用。容器仅会创建一次单例beanA，并且只有一次设置属性的机会。当每次需要时，容器不能为bean A 提供一个新的bean B。、</p>
<blockquote>
<p>A solution is to forego some inversion of control. You can <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-aware" target="_blank" rel="noopener">make bean A aware of the container</a> by implementing the <code>ApplicationContextAware</code> interface, and by <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-client" target="_blank" rel="noopener">making a getBean(“B”) call to the container</a> ask for (a typically new) bean B instance every time bean A needs it. The following is an example of this approach:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">forego v. 摒弃， 放弃</span></pre></td></tr></table></figure>

<p>一个解决方式是摒弃一些IoC。通过实现<code>ApplicationContextAware</code>接口，你可以让beanA为容器可感知的，当beanA每次需要beanB时，通过<code>getBean(&quot;B&quot;)</code>（通常是新的）调用容器每次来获取beanB实例。以下是该方法的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// a class that uses a stateful Command-style class to perform some processing</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring-API imports</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Map commandState)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// grab a new instance of the appropriate Command</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        Command command = createCommand();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        command.setState(commandState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> command.execute();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> Command <span class="title">createCommand</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// notice the Spring API dependency!</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.applicationContext.getBean(<span class="string">"command"</span>, Command<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">            ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, allows this use case to be handled in a clean fashion.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">desirable adj. 值得想望（或拥有）的; 合意的; 可取的; 受欢迎的</span></pre></td></tr></table></figure>

<p>上述是不可取的，因为业务代码可感知且耦合到了Spring框架。方法注入， Spring IoC容器的一项高级功能，允许以干净的方式来处理此用例。</p>
<blockquote>
<p>You can read more about the motivation for Method Injection in <a href="https://spring.io/blog/2004/08/06/method-injection/" target="_blank" rel="noopener">this blog entry</a>.</p>
</blockquote>
<h4 id="Lookup-method-injection"><a href="#Lookup-method-injection" class="headerlink" title="Lookup method injection"></a>Lookup method injection</h4><p>查找方法注入</p>
<blockquote>
<p>Lookup method injection is the ability of the container to override methods on <em>container managed beans</em>, to return the lookup result for another named bean in the container. The lookup typically involves a prototype bean as in the scenario described in the preceding section. The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to generate dynamically a subclass that overrides the method.</p>
</blockquote>
<p>当容器管理bean时，查找方法注入是容器重写方法的能力，返回的结果是容器中另一个命名的bean。如上节所述，查找通常涉及原型bean。Spring框架实现这种方法注入是通过生成字节码的方式，该方式通过CGLIB类库动态生成子类并且覆盖父类方法。</p>
<blockquote>
<ul>
<li>For this dynamic subclassing to work, the class that the Spring bean container will subclass cannot be <code>final</code>, and the method to be overridden cannot be <code>final</code> either.</li>
<li>Unit-testing a class that has an <code>abstract</code> method requires you to subclass the class yourself and to supply a stub implementation of the <code>abstract</code> method.</li>
<li>Concrete methods are also necessary for component scanning which requires concrete classes to pick up.</li>
<li>A further key limitation is that lookup methods won’t work with factory methods and in particular not with <code>@Bean</code> methods in configuration classes, since the container is not in charge of creating the instance in that case and therefore cannot create a runtime-generated subclass on the fly.</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">subclass v. 子类化</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pick up 获得，获取</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">limitation n. 限制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">in particular &#x3D; particularly 尤其，特别</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">in charge of 负责</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">on the fly 匆忙地，急切地，赶紧地</span></pre></td></tr></table></figure>



<ul>
<li>为了使这种动态子类生效，Spring容器进行子类化的基类不能是final的，并且方法也不能是final</li>
<li>对具有抽象方法的类进行单元测试需要您自己对该类进行子类化，并提供抽象方法的存根实现。</li>
<li>组件扫描也需要具体的方法，这需要具体的类别。</li>
<li>进一步的关键限制是查找方法不适用于工厂方法，特别是配置类中使用<code>@Bean</code>标注的方法，因为这种情况下容器不负责创建实例，因此无法创建运行时子类</li>
</ul>
<blockquote>
<p>Looking at the <code>CommandManager</code> class in the previous code snippet, you see that the Spring container will dynamically override the implementation of the <code>createCommand()</code> method. Your <code>CommandManager</code> class will not have any Spring dependencies, as can be seen in the reworked example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">rework v. 改进;改动;重写;改写</span></pre></td></tr></table></figure>



<p>查看<code>CommandManager</code>类之前的代码片段，可以看到Spring容器将会动态的重新<code>createCommand()</code>的实现，<code>CommandManager</code>类将不会具有任何Spring依赖，改进后的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// no more Spring imports!</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        Command command = createCommand();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        command.setState(commandState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> command.execute();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>In the client class containing the method to be injected (the <code>CommandManager</code> in this case), the method to be injected requires a signature of the following form:</p>
</blockquote>
<p>客户端类中包含要被注入的方法（<code>CommandManager</code>），将被注入的方法需要以下形式的签名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">public</span>|<span class="keyword">protected</span>&gt; [<span class="keyword">abstract</span>] &lt;<span class="keyword">return</span>-type&gt; theMethodName(no-arguments);</span></pre></td></tr></table></figure>

<blockquote>
<p>If the method is <code>abstract</code>, the dynamically-generated subclass implements the method. Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class. For example:</p>
</blockquote>
<p>如果方法是抽象的，动态生成的子类实现该方法。因此，动态生成的子类重写了定义在源类的具体方法，例如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCommand"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"myCommand"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The bean identified as <em>commandManager</em> calls its own method <code>createCommand()</code> whenever it needs a new instance of the <em>myCommand</em> bean. You must be careful to deploy the <code>myCommand</code> bean as a prototype, if that is actually what is needed. If it is as a <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a>, the same instance of the <code>myCommand</code> bean is returned each time.</p>
<p>Alternatively, within the annotation-based component model, you may declare a lookup method through the <code>@Lookup</code> annotation:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">whenever conj. 无论什么时候，每当</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">alternatively adv. 要不然，或者</span></pre></td></tr></table></figure>

<p><code>id</code>为commandManager的bean调用自己的<code>createCommand()</code>方法，每当他需要myCommand bean的一个新实例时。你必须以原型方式谨慎地部署myCommand bean， 如果确实需要时。如果它是作为一个单例，那么每次都会返回myCommand的相同实例。</p>
<p>或者，使用基于注解的组件模型，通过<code>@Lookup</code>注解可以声明一个查找方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        Command command = createCommand();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        command.setState(commandState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> command.execute();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Lookup</span>(<span class="string">"myCommand"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Or, more idiomatically, you may rely on the target bean getting resolved against the declared return type of the lookup method:</p>
</blockquote>
<p>或者，更习惯地说，您可能依赖于针对查找方法的声明的返回类型来解析目标Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        MyCommand command = createCommand();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        command.setState(commandState);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> command.execute();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Lookup</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title">createCommand</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Note that you will typically declare such annotated lookup methods with a concrete stub implementation, in order for them to be compatible with Spring’s component scanning rules where abstract classes get ignored by default. This limitation does not apply in case of explicitly registered or explicitly imported bean classes.</p>
</blockquote>
<p>注意，你通常使用具体的stub实现来声明这样注解的查找方法， 使得他们兼容Spring的组组件扫描规则，这里抽象类默认被忽略。此限制不适用显示注册或者显示导入的bean类</p>
<blockquote>
<p>Another way of accessing differently scoped target beans is an <code>ObjectFactory</code>/ <code>Provider</code> injection point. Check out <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-other-injection" target="_blank" rel="noopener">the section called “Scoped beans as dependencies”</a>.</p>
<p>The interested reader may also find the <code>ServiceLocatorFactoryBean</code> (in the <code>org.springframework.beans.factory.config</code> package) to be of use.</p>
</blockquote>
<p>另一种访问不同作用域目标bean的方法是<code>ObjectFactory</code>、<code>Provider</code>注入点。</p>
<p>感兴趣的读者亦可以查找<code>og.springframework.beans.factory.config</code>包中<code>ServiceLocatorFactoryBean</code>可以使用。</p>
<h4 id="Arbitrary-method-replacement"><a href="#Arbitrary-method-replacement" class="headerlink" title="Arbitrary method replacement"></a>Arbitrary method replacement</h4><p>任意方法替代</p>
<blockquote>
<p>A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation. Users may safely skip the rest of this section until the functionality is actually needed.</p>
</blockquote>
<p>较之查找方法注入，方法注入的一种不太有用的形式是使用另一个方法的实现替换被管理bean中的任意方法。用户可以安全的跳过本节的其余部分，指导实际需要该功能位置</p>
<blockquote>
<p>With XML-based configuration metadata, you can use the <code>replaced-method</code> element to replace an existing method implementation with another, for a deployed bean. Consider the following class, with a method computeValue, which we want to override:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// some real code...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// some other methods...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>A class implementing the <code>org.springframework.beans.factory.support.MethodReplacer</code> interface provides the new method definition.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * meant to be used to override the existing computeValue(String)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * implementation in MyValueCalculator</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">MethodReplacer</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        String input = (String) args[<span class="number">0</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> ...;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The bean definition to deploy the original class and specify the method override would look like this:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- arbitrary method replacement --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>You can use one or more contained <code>elements within the</code> element to indicate the method signature of the method being overridden. The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class. For convenience, the type string for an argument may be a substring of the fully qualified type name. For example, the following all match <code>java.lang.String</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">java.lang.String</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">String</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">Str</span></pre></td></tr></table></figure>

<blockquote>
<p>Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by allowing you to type only the shortest string that will match an argument type.</p>
</blockquote>
<h2 id="7-5-Bean-scopes"><a href="#7-5-Bean-scopes" class="headerlink" title="7.5 Bean scopes"></a>7.5 Bean scopes</h2><p>bean 作用域</p>
<blockquote>
<p>When you create a bean definition, you create a <em>recipe</em>for creating actual instances of the class defined by that bean definition. The idea that a bean definition is a recipe is important, because it means that, as with a class, you can create many object instances from a single recipe.</p>
</blockquote>
<p>当创建bean定义时，实际创建了那个bean定义的类实例的食谱。bean定义是一份食谱的想法很重要，因为它意味着，对于一个类，可以根据一份简单的食谱谱创建很多对象实例。</p>
<blockquote>
<p>You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition, but also the <em>scope</em> of the objects created from a particular bean definition. This approach is powerful and flexible in that you can <em>choose</em> the scope of the objects you create through configuration instead of having to bake in the scope of an object at the Java class level. Beans can be defined to be deployed in one of a number of scopes: out of the box, the Spring Framework supports seven scopes, five of which are available only if you use a web-aware <code>ApplicationContext</code>.</p>
</blockquote>
<p>你不仅可以控制各种各样的依赖和配置信息值，配置信息值被注入到基于特定bean定义创建的对象，还可以控制对象的作用域。该方法功能强大且灵活，因为你可以选择要创建对象的作用域，这是通过配置而不是java类级别上作用域的设置。bean可以被定义为部署为大量的作用域：开箱即用，Spring框架支持7种作用域，只有当你使用web可感知的<code>ApplicationContext</code>，其中五个可用。</p>
<blockquote>
<p>The following scopes are supported out of the box. You can also create <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-custom" target="_blank" rel="noopener">a custom scope.</a></p>
</blockquote>
<p>以下作用域支持开箱即用，你也可以创建自定义的scope</p>
<p><strong>Table 7.3. Bean scopes</strong></p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a></td>
<td>(Default) Scopes a single bean definition to a single object instance per Spring IoC container.</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype" target="_blank" rel="noopener">prototype</a></td>
<td>Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-request" target="_blank" rel="noopener">request</a></td>
<td>Scopes a single bean definition to the lifecycle of a single HTTP request; that is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-session" target="_blank" rel="noopener">session</a></td>
<td>Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-global-session" target="_blank" rel="noopener">globalSession</a></td>
<td>Scopes a single bean definition to the lifecycle of a global HTTP <code>Session</code>. Typically only valid when used in a Portlet context. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-application" target="_blank" rel="noopener">application</a></td>
<td>Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#websocket-stomp-websocket-scope" target="_blank" rel="noopener">websocket</a></td>
<td>Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody></table>
<p><strong>Table 7.3. Bean作用域</strong></p>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-singleton" target="_blank" rel="noopener">singleton</a></td>
<td>(默认) 每个Spring IoC容器将单个bean定义限定为单个对象实例</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-prototype" target="_blank" rel="noopener">prototype</a></td>
<td>限定单个bean定义为多个对象实例</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-request" target="_blank" rel="noopener">request</a></td>
<td>将单个bean定义的范围限定为单个HTTP请求的生命周期； 也就是说，每个HTTP请求都有其自己的bean实例，它是在单个bean定义的后面创建的。 仅在可感知网络的Spring<code>ApplicationContext</code>上下文中有效。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-session" target="_blank" rel="noopener">session</a></td>
<td>将单个bean定义的范围限定为 HTTP <code>Session</code>的生命周期。仅在可感知网络的Spring<code>ApplicationContext</code>上下文中有效。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-global-session" target="_blank" rel="noopener">globalSession</a></td>
<td>将单个bean定义的范围限定为全局 HTTP <code>Session</code>的生命周期. Typically only valid when used in a Portlet context. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-application" target="_blank" rel="noopener">application</a></td>
<td>将单个bean定义的范围限定为<code>ServletContext</code>的生命周期. 仅在可感知网络的Spring<code>ApplicationContext</code>上下文中有效。</td>
</tr>
<tr>
<td><a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#websocket-stomp-websocket-scope" target="_blank" rel="noopener">websocket</a></td>
<td>将单个bean定义的范围限定为<code>WebSocket</code>的声明周期. 仅在可感知网络的Spring<code>ApplicationContext</code>上下文中有效。</td>
</tr>
</tbody></table>
<blockquote>
<p>As of Spring 3.0, a <em>thread scope</em> is available, but is not registered by default. For more information, see the documentation for <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/context/support/SimpleThreadScope.html" target="_blank" rel="noopener"><code>SimpleThreadScope</code></a>. For instructions on how to register this or any other custom scope, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-custom-using" target="_blank" rel="noopener">the section called “Using a custom scope”</a>.</p>
</blockquote>
<p>从Spring3.0开始，支持线程作用域，默认下没有注册。更多信息请查看<code>SimpleThreadScope</code>文档。如何注册该作用域或者其他自定义的作用域，请看<code>Using a custom scope</code></p>
<h3 id="7-5-1-The-singleton-scope"><a href="#7-5-1-The-singleton-scope" class="headerlink" title="7.5.1 The singleton scope"></a>7.5.1 The singleton scope</h3><p>单例作用域</p>
<blockquote>
<p>Only one <em>shared</em> instance of a singleton bean is managed, and all requests for beans with an id or ids matching that bean definition result in that one specific bean instance being returned by the Spring container.</p>
</blockquote>
<p>仅管理一个bean的共享实例，所有具有对该bean定义匹配的id或者ids的请求，都将导致Spring容器返回一个特定的bean实例。</p>
<blockquote>
<p>To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring IoC container creates <em>exactly one</em> instance of the object defined by that bean definition. This single instance is stored in a cache of such singleton beans, and <em>all subsequent requests and references</em> for that named bean return the cached object.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">to put it another way 换句话说</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">exactly adv. 精确地;确切地;正好</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">subsequent adj. 随后的;后来的； 在...之后</span></pre></td></tr></table></figure>

<p>换句话说，当您定义一个bean定义并且其作用域为单例时，Spring IoC容器会创建该bean定义定义的对象的<strong>一个</strong>实例。 该单个实例存储在此类单例bean的缓存中，并且该命名bean的所有后续请求和引用返回缓存的对象。</p>
<p><img src="E:/Documents/hexo/source/_posts/images/singleton.png" alt=""></p>
<blockquote>
<p>Spring’s concept of a singleton bean differs from the Singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF Singleton hard-codes the scope of an object such that one <em>and only one</em> instance of a particular class is created <em>per ClassLoader</em>. The scope of the Spring singleton is best described as <em>per container and per bean</em>. This means that if you define one bean for a particular class in a single Spring container, then the Spring container creates one <em>and only one</em> instance of the class defined by that bean definition. <em>The singleton scope is the default scope in Spring</em>. To define a bean as a singleton in XML, you would write, for example:</p>
</blockquote>
<p>Spring单例bean的概念不同于GoF书中单例设计模式中的定义。GoF单例模式对对象作用域进行硬编码，以至每个<code>ClassLoader</code>创建一个特定的类，并且仅创建一个。Spring单例作用域最好描述为单个容器和单个bean。这意味着，如果在单个Spring容器中定义一个特定类的bean，根据那个bean定义Spring容器创建一个仅一个类的实例。<code>singleton</code>是Spring容器默认的作用域。在XML中定义一个单例bean，如下例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span></pre></td></tr></table></figure>

<h3 id="7-5-2-The-prototype-scope"><a href="#7-5-2-The-prototype-scope" class="headerlink" title="7.5.2 The prototype scope"></a>7.5.2 The prototype scope</h3><p>原型作用域</p>
<blockquote>
<p>The non-singleton, prototype scope of bean deployment results in the <em>creation of a new bean instance</em> every time a request for that specific bean is made. That is, the bean is injected into another bean or you request it through a <code>getBean()</code> method call on the container. As a rule, use the prototype scope for all stateful beans and the singleton scope for stateless beans.</p>
</blockquote>
<p>非单例，原型作用域部署，每次请求特定bean都会创建一个新的bean实例。也就是说，该bean被注入到另一个bean或者通过调用用容器<code>getBean</code>请求的bean</p>
<blockquote>
<p>The following diagram illustrates the Spring prototype scope. <em>A data access object (DAO) is not typically configured as a prototype, because a typical DAO does not hold any conversational state; it was just easier for this author to reuse the core of the singleton diagram.</em></p>
</blockquote>
<p>下面的图说明Spring的原型作用域。数据访问对象通常不会配置为原型模式，因为通常dao不能处理会话状态。对作者而言，重用单例图将更加简单</p>
<p><img src="E:/Documents/hexo/source/_posts/images/prototype.png" alt=""></p>
<blockquote>
<p>The following example defines a bean as a prototype in XML:</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultAccountService"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean: the container instantiates, configures, and otherwise assembles a prototype object, and hands it to the client, with no further record of that prototype instance. Thus, although <em>initialization</em> lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured <em>destruction</em> lifecycle callbacks are <em>not</em> called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype bean(s) are holding. To get the Spring container to release resources held by prototype-scoped beans, try using a custom <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp" target="_blank" rel="noopener">bean post-processor</a>, which holds a reference to beans that need to be cleaned up.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">in contrast to 与...相反</span></pre></td></tr></table></figure>

<p>与其他作用于相反，Spring不会管理原型bean的完整生命周期：容器实例化，配置然后组装一个原型对象，然后传递给客户端，而没有原型实例对象的进一步记录。因此不管范围如何，都会调用对象的例化生命周期回调函数，在原型作用域情况下，配置的销毁生命周期回调函数<code>destroy()</code>不会被调用。客户端代码必须清理原型作用域对象，并且释放原型对象持有的宝贵资源。为了能使Spring释放原型对象持有的资源，尝试使用自定义的bean后置处理器，它持有要清理bean的引用。</p>
<blockquote>
<p>In some respects, the Spring container’s role in regard to a prototype-scoped bean is a replacement for the Java <code>new</code> operator. All lifecycle management past that point must be handled by the client. (For details on the lifecycle of a bean in the Spring container, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-lifecycle" target="_blank" rel="noopener">Section 7.6.1, “Lifecycle callbacks”</a>.)</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">in some respects 在某些方面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">in regard to 关于</span></pre></td></tr></table></figure>

<p>在某些方面，Spring容器在原型作用域bean的角色是java<code>new</code>运算符的替代。超过该时间点的所有生命周期管理都必须交给客户端处理。Spring容器bean生命周期的详细信息，查看7.6.1部分</p>
<h3 id="7-5-3-Singleton-beans-with-prototype-bean-dependencies"><a href="#7-5-3-Singleton-beans-with-prototype-bean-dependencies" class="headerlink" title="7.5.3 Singleton beans with prototype-bean dependencies"></a>7.5.3 Singleton beans with prototype-bean dependencies</h3><p>具有原型bean依赖的单例bean</p>
<blockquote>
<p>When you use singleton-scoped beans with dependencies on prototype beans, be aware that <em>dependencies are resolved at instantiation time</em>. Thus if you dependency-inject a prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency-injected into the singleton bean. The prototype instance is the sole instance that is ever supplied to the singleton-scoped bean.</p>
</blockquote>
<p>当你使用具有原型bean依赖的单例作用域bean，要清楚依赖在初始化时候被解析。因此如果你将一个原型bean注入到一个单例作用域bean时，一个新的原型bean被初始化并被注入到单例bean中。原型实例是曾经提供给单例bean的唯一实例</p>
<blockquote>
<p>However, suppose you want the singleton-scoped bean to acquire a new instance of the prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only <em>once</em>, when the Spring container is instantiating the singleton bean and resolving and injecting its dependencies. If you need a new instance of a prototype bean at runtime more than once, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-method-injection" target="_blank" rel="noopener">Section 7.4.6, “Method injection”</a></p>
</blockquote>
<p>但是，假如你想在运行时使用单例bena去重复获得一个原型bean的新实例时。你不能将原型bean注入到单例bean中，因为当Spring容器实例化单例bean并解析注入其依赖时，注入仅发生一次。如果在运行时你需要多次新的原型实例，请看Section7.4.6</p>
<h3 id="7-5-4-Request-session-global-session-application-and-WebSocket-scopes"><a href="#7-5-4-Request-session-global-session-application-and-WebSocket-scopes" class="headerlink" title="7.5.4 Request, session, global session, application, and WebSocket scopes"></a>7.5.4 Request, session, global session, application, and WebSocket scopes</h3><blockquote>
<p>The <code>request</code>, <code>session</code>, <code>globalSession</code>, <code>application</code>, and <code>websocket</code> scopes are <em>only</em> available if you use a web-aware Spring <code>ApplicationContext</code> implementation (such as <code>XmlWebApplicationContext</code>). If you use these scopes with regular Spring IoC containers such as the <code>ClassPathXmlApplicationContext</code>, an <code>IllegalStateException</code> will be thrown complaining about an unknown bean scope.</p>
</blockquote>
<p>仅当你使用web感知的<code>ApplicationContext</code>实现时（比如<code>XmlWebApplicationContext</code>），<code>request</code>, <code>session</code>,<code>globalSession</code>,<code>application</code>,<code>websocket</code>作用域才可用。如果你使用常规的Spring IoC 容器例如<code>ClassPathXmlApplicationContext</code>，会抛出未知bean作用域的<code>IllegalStateException</code></p>
<h4 id="Initial-web-configuration"><a href="#Initial-web-configuration" class="headerlink" title="Initial web configuration"></a>Initial web configuration</h4><blockquote>
<p>To support the scoping of beans at the <code>request</code>, <code>session</code>, <code>globalSession</code>, <code>application</code>, and <code>websocket</code> levels (web-scoped beans), some minor initial configuration is required before you define your beans. (This initial setup is <em>not</em> required for the standard scopes, <code>singleton</code> and <code>prototype</code>.)</p>
</blockquote>
<p>为了支持<code>request</code>, <code>session</code>, <code>globalSession</code>, <code>application</code>, and <code>websocket</code> 级别（web作用域bean）的作用域bean， 在定义bean之前，需要一些小的初始配置。（<code>singleton</code>， <code>prototype</code>不需要此初始配置）</p>
<blockquote>
<p>How you accomplish this initial setup depends on your particular Servlet environment.</p>
</blockquote>
<p>如何完成此初始配置将依赖于你特定的Servlet环境</p>
<blockquote>
<p>If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by the Spring <code>DispatcherServlet</code> or <code>DispatcherPortlet</code>, then no special setup is necessary: <code>DispatcherServlet</code> and <code>DispatcherPortlet</code> already expose all relevant state.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">in effect 实际上，事实上</span></pre></td></tr></table></figure>

<p>如果在Spring Web MVC中访问作用域的bean，事实上，<code>DispatcherServlet</code>或者<code>DispatcherPortlet</code>来处理请求，无需进行特殊配置：<code>DispatcherServlet</code>或者<code>DispatcherPortlet</code>已经暴露了所有相关状态</p>
<blockquote>
<p>If you use a Servlet 2.5 web container, with requests processed outside of Spring’s <code>DispatcherServlet</code> (for example, when using JSF or Struts), you need to register the <code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>. For Servlet 3.0+, this can be done programmatically via the <code>WebApplicationInitializer</code> interface. Alternatively, or for older containers, add the following declaration to your web application’s <code>web.xml</code> file:</p>
</blockquote>
<p>如果你使用Servlet 2.5的web容器，其请求都是在Spring的<code>DispatcherServlet</code>的外部处理（例如使用JSF或者Sturts），你需要注册<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>。对于Servlet3.0+，可以通过<code>WebApplicationInitializer</code>接口程序化完成。还有，对于老的容器，在web应用的<code>web.xml</code>文件中添加以下声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            org.springframework.web.context.request.RequestContextListener</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Alternatively, if there are issues with your listener setup, consider using Spring’s <code>RequestContextFilter</code>. The filter mapping depends on the surrounding web application configuration, so you have to change it as appropriate.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">alternatively adv. 要不然，或者</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">alternative adj. 可供选择的，可代替的；备选的；备用的；其他的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">as appropriate &#x3D; appropriately adv. 适当地，恰当地</span></pre></td></tr></table></figure>

<p>另外，    如果你的监听器设置存在问题，考虑使用Spring的<code>RequestContextFilter</code>。过滤器映射取决于周围web应用的配置，所以你应当适当地修改它</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p><code>DispatcherServlet</code>, <code>RequestContextListener</code>, and <code>RequestContextFilter</code> all do exactly the same thing, namely bind the HTTP request object to the <code>Thread</code> that is servicing that request. This makes beans that are request-chain and session-scoped available further down the call chain.</p>
</blockquote>
<p><code>DispatcherServlet</code>, <code>RequestContextListener</code>, and <code>RequestContextFilter</code>都做几乎相同的事情，称之为绑定Http请求对象到处理请求的线程。这使得在请求链和会话范围内的bean可以在调用链的更下游使用。</p>
<h4 id="Request-scope"><a href="#Request-scope" class="headerlink" title="Request scope"></a>Request scope</h4><blockquote>
<p>Consider the following XML configuration for a bean definition:</p>
</blockquote>
<p>考虑以下XML配置中的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.foo.LoginAction"</span> <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The Spring container creates a new instance of the <code>LoginAction</code> bean by using the <code>loginAction</code> bean definition for each and every HTTP request. That is, the <code>loginAction</code> bean is scoped at the HTTP request level. You can change the internal state of the instance that is created as much as you want, because other instances created from the same <code>loginAction</code> bean definition will not see these changes in state; they are particular to an individual request. When the request completes processing, the bean that is scoped to the request is discarded.</p>
</blockquote>
<p>Spring容器通过<code>loginAction</code>bean定义每次为每个HTTP请求创建了一个新的<code>LoginAction</code>新实例。也就是说，<code>loginAction</code>是在HTTP请求级别的作用域。你可以根据需要更改创建的实例内部的状态，因为从相同的<code>loginAction</code>bean定义中创建的其他实例将不会看到状态的变化。它们对于单个请求是特定的。当请求过程完成，<code>request</code>作用域bean 将被丢弃。</p>
<blockquote>
<p>When using annotation-driven components or Java Config, the <code>@RequestScope</code> annotation can be used to assign a component to the <code>request</code> scope.</p>
</blockquote>
<p>当使用注解驱动的组件或者java配置，<code>@RequestScope</code>注解可以用于将组件指派为<code>request</code>作用域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestScope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="Session-scope"><a href="#Session-scope" class="headerlink" title="Session scope"></a>Session scope</h4><p>session作用域</p>
<blockquote>
<p>Consider the following XML configuration for a bean definition:</p>
</blockquote>
<p>考虑以下XML配置中的bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The Spring container creates a new instance of the <code>UserPreferences</code> bean by using the <code>userPreferences</code> bean definition for the lifetime of a single HTTP <code>Session</code>. In other words, the <code>userPreferences</code> bean is effectively scoped at the HTTP <code>Session</code> level. As with <code>request-scoped</code> beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP <code>Session</code> instances that are also using instances created from the same <code>userPreferences</code> bean definition do not see these changes in state, because they are particular to an individual HTTP <code>Session</code>. When the HTTP <code>Session</code> is eventually discarded, the bean that is scoped to that particular HTTP <code>Session</code> is also discarded.</p>
</blockquote>
<p>Spring容器通过<code>userPreferences</code>创建了在单个Http<code>Session</code>生命期内的<code>UserPreferences</code>bean的新实例。换句话说，<code>userPreferences</code>实际上是Http<code>Session</code>作用域级别的bean。与<code>request-scoped</code>bean相比，你可以根据需要更改实例的内部状态，要明白从相同的<code>userPreferences</code>bean定义创建的其他Http<code>Session</code>实例看不到状态中的这些变化，因为他们是特定于单个HTTP <code>Session</code>的。当HTTP<code>Session</code>最终被丢弃，特定于Http<code>Session</code>bean也被丢弃。</p>
<blockquote>
<p>When using annotation-driven components or Java Config, the <code>@SessionScope</code> annotation can be used to assign a component to the <code>session</code> scope.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">assign v. 分派（工作），布置（作业）；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">		分配，配给； </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">		委派，指派；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">		赋予，给予</span></pre></td></tr></table></figure>

<p>当使用注解驱动或者java配置，<code>@SessionScope</code>注解可被用来将组件指派为<code>session</code>作用域</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionScope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPreferences</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="Global-session-scope"><a href="#Global-session-scope" class="headerlink" title="Global session scope"></a>Global session scope</h4><blockquote>
<p>Consider the following bean definition:</p>
</blockquote>
<p>考虑以下bean定义：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"globalSession"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>globalSession</code> scope is similar to the standard HTTP <code>Session</code> scope (<a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-scopes-session" target="_blank" rel="noopener">described above</a>), and applies only in the context of portlet-based web applications. The portlet specification defines the notion of a global <code>Session</code> that is shared among all portlets that make up a single portlet web application. Beans defined at the <code>globalSession</code> scope are scoped (or bound) to the lifetime of the global portlet <code>Session</code>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">notion n. 看法，概念，理念</span></pre></td></tr></table></figure>

<p><code>globalSession</code>作用域和标准的Http <code>Session</code>作用域（上述描述的）相似，且仅适用于基于portlet的web应用环境。portlet规范定义了全局会话的概念，全局会话在组成单个portlet web应用的所有portlet间共享。<code>globalSession</code>作用域的bean被限定（绑定）到全局portlet会话的生命期</p>
<blockquote>
<p>If you write a standard Servlet-based web application and you define one or more beans as having <code>globalSession</code> scope, the standard HTTP <code>Session</code> scope is used, and no error is raised.</p>
</blockquote>
<p>如果编写一个标准的基于<code>Servlet</code>web应用程序，需要将一个或多个bean定义为<code>globalSession</code>作用域，则将使用标准的HTTP<code>Session</code>作用域，且不会发生任何错误。</p>
<h4 id="Application-scope"><a href="#Application-scope" class="headerlink" title="Application scope"></a>Application scope</h4><blockquote>
<p>Consider the following XML configuration for a bean definition:</p>
</blockquote>
<p>考虑下列bean定义xml配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"appPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.AppPreferences"</span> <span class="attr">scope</span>=<span class="string">"application"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The Spring container creates a new instance of the <code>AppPreferences</code> bean by using the <code>appPreferences</code> bean definition once for the entire web application. That is, the <code>appPreferences</code> bean is scoped at the <code>ServletContext</code> level, stored as a regular <code>ServletContext</code> attribute. This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton per <code>ServletContext</code>, not per Spring ‘ApplicationContext’ (for which there may be several in any given web application), and it is actually exposed and therefore visible as a <code>ServletContext</code> attribute.</p>
</blockquote>
<p>Spring容器使用一次<code>appPreferences</code>bean定义为整个web应用创建一个<code>AppPreferences</code>bean。也就是说，<code>appPreferences</code>bean是<code>ServletContext</code>级别的作用域，作为常规<code>ServletContext</code>属性存储。有点类似Spring单例bean但是有两个重要的不同：它对于每个<code>ServletContext</code>是单例的，而不是每个Spring的<code>ApplicationContext</code>（在任何给定的web应用程序可能存在多个），且它实际上时公开的，因此也是可见的<code>ServletContext</code>属性。</p>
<blockquote>
<p>When using annotation-driven components or Java Config, the <code>@ApplicationScope</code> annotation can be used to assign a component to the <code>application</code> scope.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApplicationScope</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppPreferences</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h4 id="Scoped-beans-as-dependencies"><a href="#Scoped-beans-as-dependencies" class="headerlink" title="Scoped beans as dependencies"></a>Scoped beans as dependencies</h4><p>…</p>
<h5 id="Choosing-the-type-of-proxy-to-create"><a href="#Choosing-the-type-of-proxy-to-create" class="headerlink" title="Choosing the type of proxy to create"></a>Choosing the type of proxy to create</h5><p>…</p>
<h3 id="7-5-5-Custom-scopes"><a href="#7-5-5-Custom-scopes" class="headerlink" title="7.5.5 Custom scopes"></a>7.5.5 Custom scopes</h3><h4 id="Creating-a-custom-scope"><a href="#Creating-a-custom-scope" class="headerlink" title="Creating a custom scope"></a>Creating a custom scope</h4><p>…</p>
<h4 id="Using-a-custom-scope"><a href="#Using-a-custom-scope" class="headerlink" title="Using a custom scope"></a>Using a custom scope</h4><p>…</p>
<h2 id="7-6-Customizing-the-nature-of-a-bean"><a href="#7-6-Customizing-the-nature-of-a-bean" class="headerlink" title="7.6 Customizing the nature of a bean"></a>7.6 Customizing the nature of a bean</h2><p>自定义bean性质</p>
<h3 id="7-6-1-Lifecycle-callbacks"><a href="#7-6-1-Lifecycle-callbacks" class="headerlink" title="7.6.1 Lifecycle callbacks"></a>7.6.1 Lifecycle callbacks</h3><blockquote>
<p>To interact with the container’s management of the bean lifecycle, you can implement the Spring <code>InitializingBean</code> and <code>DisposableBean</code> interfaces. The container calls <code>afterPropertiesSet()</code> for the former and <code>destroy()</code> for the latter to allow the bean to perform certain actions upon initialization and destruction of your beans.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">perform certain actions 执行都写操作</span></pre></td></tr></table></figure>

<p>为了与容器对bean生命周期管理的交互，你可是实现<code>InitializingBean</code>和<code>DisposableBean</code>接口。容器会调用前者的<code>afterPropertiesSet()</code>方法，调用后者的<code>destroy()</code>方法，以允许bean在初始化和销毁时执行某些操作</p>
<blockquote>
<p>The JSR-250 <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are generally considered best practice for receiving lifecycle callbacks in a modern Spring application. Using these annotations means that your beans are not coupled to Spring specific interfaces. For details see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-postconstruct-and-predestroy-annotations" target="_blank" rel="noopener">Section 7.9.8, “@PostConstruct and @PreDestroy”</a>.</p>
<p>If you don’t want to use the JSR-250 annotations but you are still looking to remove coupling consider the use of init-method and destroy-method object definition metadata.</p>
</blockquote>
<p>JSR-250<code>@PostConstruct</code>和<code>@PreDstroy</code>注解被认为是现代Spring应用程序接收生命周期回调的最佳实践。使用这些注解意味着，你的bean不在耦合Spring特定的接口。详细信息请看Section 7.9.8。</p>
<p>如果你不想使用JSR-250但你仍在寻找消除耦合的方法，可以考虑对象定义元数据的初始化方法<code>init-method</code>和销毁方法<code>destryo-method</code></p>
<blockquote>
<p>Internally, the Spring Framework uses <code>BeanPostProcessor</code> implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not offer out-of-the-box, you can implement a <code>BeanPostProcessor</code> yourself. For more information, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension" target="_blank" rel="noopener">Section 7.8, “Container Extension Points”</a>.</p>
</blockquote>
<p>Spring框架内部使用<code>BeanPostProcessor</code>后者处理器实现来处理接口的回调，它可以查找并调用合适的接口。如果你需要自定义功能或者其他生命周期行为，Spring不能提供开箱即用，你可以自己实现<code>BeanPostProcessor</code>。详细信息请看Section 7.8</p>
<blockquote>
<p>In addition to the initialization and destruction callbacks, Spring-managed objects may also implement the <code>Lifecycle</code> interface so that those objects can participate in the startup and shutdown process as driven by the container’s own lifecycle.</p>
</blockquote>
<p>除了初始化和销毁回调，Spring管理的对象也可以实现<code>Lifecycle</code>接口，以至那些对象在自身生命周期的驱动下能够参与启动关闭过程</p>
<blockquote>
<p>The lifecycle callback interfaces are described in this section.</p>
</blockquote>
<p>本章描述生命周期回调接口</p>
<h4 id="Initialization-callbacks"><a href="#Initialization-callbacks" class="headerlink" title="Initialization callbacks"></a>Initialization callbacks</h4><p>初始化回调接口</p>
<blockquote>
<p>The <code>org.springframework.beans.factory.InitializingBean</code> interface allows a bean to perform initialization work after all necessary properties on the bean have been set by the container. The <code>InitializingBean</code> interface specifies a single method:</p>
</blockquote>
<p><code>org.springframework.beans.factory.InitializingBean</code>接口在bean所有必要属性都已通过容器设置完毕后，允许bean执行初始化工作。<code>InitializingBean</code>接口指定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> throw Exception</span>;</span></pre></td></tr></table></figure>

<blockquote>
<p>It is recommended that you do not use the <code>InitializingBean</code> interface because it unnecessarily couples the code to Spring. Alternatively, use the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-postconstruct-and-predestroy-annotations" target="_blank" rel="noopener"><code>@PostConstruct</code></a> annotation or specify a POJO initialization method. In the case of XML-based configuration metadata, you use the <code>init-method</code> attribute to specify the name of the method that has a void no-argument signature. With Java config, you use the <code>initMethod</code> attribute of <code>@Bean</code>, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-java-lifecycle-callbacks" target="_blank" rel="noopener">the section called “Receiving lifecycle callbacks”</a>. For example, the following:</p>
</blockquote>
<p>建议你不要使用<code>InitializingBean</code>接口，因为它不必要的将代码耦合到Spring。 或者可以使用<code>@PostConstruct</code>注解或者指定POJO初始化方法。在基于xml的元配置数据例子中，你可以使用<code>init-method</code>属性指定一个无参无返回值的方法名。使用java配置，可以使用<code>@Bean</code>注解的<code>initMethod</code>属性。例如，下面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// do some initialization work</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>几乎等同于</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// do some initialization work</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>but does not couple the code to Spring. 但代码没有与Spring解耦</p>
</blockquote>
<h4 id="Destruction-callbacks"><a href="#Destruction-callbacks" class="headerlink" title="Destruction callbacks"></a>Destruction callbacks</h4><p>销毁回调</p>
<blockquote>
<p>Implementing the <code>org.springframework.beans.factory.DisposableBean</code> interface allows a bean to get a callback when the container containing it is destroyed. The <code>DisposableBean</code> interface specifies a single method:</p>
</blockquote>
<p>实现<code>org.springframework.bean.factory.DisposableBean</code>接口，当包含它的容器销毁时，允许bean执行一个回调。<code>DisposableBean</code>接口指定了一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> throw Exception</span>;</span></pre></td></tr></table></figure>

<blockquote>
<p>It is recommended that you do not use the <code>DisposableBean</code> callback interface because it unnecessarily couples the code to Spring. Alternatively, use the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-postconstruct-and-predestroy-annotations" target="_blank" rel="noopener"><code>@PreDestroy</code></a> annotation or specify a generic method that is supported by bean definitions. With XML-based configuration metadata, you use the <code>destroy-method</code> attribute on the <code>&lt;bean/&gt;</code>. With Java config, you use the <code>destroyMethod</code> attribute of <code>@Bean</code>, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-java-lifecycle-callbacks" target="_blank" rel="noopener">the section called “Receiving lifecycle callbacks”</a>. For example, the following definition:</p>
</blockquote>
<p>不建议使用<code>DisposableBean</code>回调接口，因为不必要的将代码耦合到Spring，可选地，你可以使用<code>@PreDestroy</code>注解或者指定一个bean定义支持的通用方法。对于基于xml的配置元数据，使用<code>&lt;bean/&gt;</code>的<code>destroy-method</code>属性。对于ava配置，使用<code>@Bean</code>注解的<code>destroyMethod</code>属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>几乎等同于</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.AnotherExampleBean"</span>/&gt;</span></span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>but does not couple the code to Spring.</p>
</blockquote>
<blockquote>
<p>The <code>destroy-method</code> attribute of a <code>&lt;bean/&gt;</code> element can be assigned a special <code>(inferred)</code> value which instructs Spring to automatically detect a public <code>close</code> or <code>shutdown</code> method on the specific bean class (any class that implements <code>java.lang.AutoCloseable</code> or <code>java.io.Closeable</code> would therefore match). This special <code>(inferred)</code> value can also be set on the <code>default-destroy-method</code> attribute of a <code>&lt;bean/&gt;</code> element to apply this behavior to an entire set of beans (see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-default-init-destroy-methods" target="_blank" rel="noopener">the section called “Default initialization and destroy methods”</a>). Note that this is the default behavior with Java config</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">inferred adj. 推断的</span></pre></td></tr></table></figure>

<p><code>&lt;bean/&gt;</code>元素的<code>destroy-method</code>可以指定为一个特殊<code>inferred</code>值，它指示Spring自动检测特定bean类上的公共的<code>close</code>或者<code>shutdown</code>方法（任何实现了<code>java.lang.AutoCloseable</code>或者<code>java.io.CloseAble</code>的类都将因此匹配）。这个特殊 <code>inferred</code>值也能被设置在<code>&lt;bean/&gt;</code>的<code>default-destroy-method</code>属性上。将这个行为应用到整个bean集。请注意这是java配置的默认行为</p>
<h4 id="Default-initialization-and-destroy-methods"><a href="#Default-initialization-and-destroy-methods" class="headerlink" title="Default initialization and destroy methods"></a>Default initialization and destroy methods</h4><p>默认的初始化和销毁方法</p>
<blockquote>
<p>When you write initialization and destroy method callbacks that do not use the Spring-specific <code>InitializingBean</code> and <code>DisposableBean</code> callback interfaces, you typically write methods with names such as <code>init()</code>, <code>initialize()</code>, <code>dispose()</code>, and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency.</p>
</blockquote>
<p>当你编写初始化和销毁回调方法时，不要使用Spring特定的<code>InitializingBean</code>和<code>DisposableBean</code>回调接口，通常编写方法例如<code>init()</code>，<code>initialize()</code>，<code>dispose()</code>等等。理想情况下，这样的生命周期回调方法的名称在整个项目中都是标准化的，因此所有开发人员都使用相同的方法名称并确保一致性。</p>
<blockquote>
<p>You can configure the Spring container to <code>look</code> for named initialization and destroy callback method names on <em>every</em> bean. This means that you, as an application developer, can write your application classes and use an initialization callback called <code>init()</code>, without having to configure an <code>init-method=&quot;init&quot;</code> attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract described previously). This feature also enforces a consistent naming convention for initialization and destroy method callbacks.</p>
</blockquote>
<p>你可以配置Spring容器查找每个bean上的初始化和销毁回调方法。这意味着你作为一个应用开发者，能够编写应用类并且使用名为<code>init()</code>的初始化回调方法，而不必为每个bean定义<code>init-method=&quot;init&quot;</code>。Spring IoC容器在bean创建时会调用那个方法（并根据前面描述的标准生命周期协定）。这个功能也强制初始化和销毁回调方法一致的命名协定。</p>
<blockquote>
<p>Suppose that your initialization callback methods are named <code>init()</code> and destroy callback methods are named <code>destroy()</code>. Your class will resemble the class in the following example.</p>
</blockquote>
<p>假设你的初始化回调名为<code>init()</code> ，销毁回调为<code>destroy()</code>。你的类将和下述例子相似：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultBlogService</span> <span class="keyword">implements</span> <span class="title">BlogService</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> BlogDao blogDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBlogDao</span><span class="params">(BlogDao blogDao)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.blogDao = blogDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// this is (unsurprisingly) the initialization callback method</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.blogDao == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The [blogDao] property must be set."</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-init-method</span>=<span class="string">"init"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"blogService"</span> <span class="attr">class</span>=<span class="string">"com.foo.DefaultBlogService"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"blogDao"</span> <span class="attr">ref</span>=<span class="string">"blogDao"</span> /&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The presence of the <code>default-init-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element attribute causes the Spring IoC container to recognize a method called <code>init</code> on beans as the initialization method callback. When a bean is created and assembled, if the bean class has such a method, it is invoked at the appropriate time.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">presence n. 出席，到场；风度，风采，仪态</span></pre></td></tr></table></figure>

<p>顶级<code>&lt;beans/&gt;</code>元素上的<code>default-init-method</code>属性，导致Spring IoC容器将bean上的<code>init</code>方法识别为初始化方法回调。创建和组装bean时，如果bean具有这样的方法，则会在适当的时间调用它。</p>
<blockquote>
<p>You configure destroy method callbacks similarly (in XML, that is) by using the <code>default-destroy-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element.</p>
</blockquote>
<p>相似地，可通过顶层<code>&lt;beans/&gt;</code>元素上的<code>default-destroy-method</code>属性，配置销毁方法回调。</p>
<blockquote>
<p>Where existing bean classes already have callback methods that are named at variance with the convention, you can override the default by specifying (in XML, that is) the method name using the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean/&gt;</code> itself.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">at variance with sth. 与...不一致，相矛盾</span></pre></td></tr></table></figure>

<p>如果现有的bean已经具有符合命名规范的回调方法，则可以通过（在xml中）指定<code>&lt;bean/&gt;</code>元素本身的<code>init-method</code>和<code>destroy-method</code>方法名称来覆盖默认值。</p>
<blockquote>
<p>The Spring container guarantees that a configured initialization callback is called immediately after a bean is supplied with all dependencies. Thus the initialization callback is called on the raw bean reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target bean is fully created <em>first</em>, <em>then</em> an AOP proxy (for example) with its interceptor chain is applied. If the target bean and the proxy are defined separately, your code can even interact with the raw target bean, by passing the proxy. Hence, it would be inconsistent to apply the interceptors to the init method, because doing so would couple the lifecycle of the target bean with its proxy/interceptors and leave strange semantics when your code interacts directly to the raw target bean.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">apply sth. to sth. 应用;运用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">inconsistent adj.  (人)反复无常的,易变的 ; 不能始终如一的;时好时坏的 ;  不一致的;相排斥的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">semantics n. 语义学</span></pre></td></tr></table></figure>

<p>Spring容器保证，在为bean提供所有依赖项后，会立即调用配置的初始化回调。因此，初始化回调会在原生bean引用上被调用，也就是说，AOP拦截器等还没应予于bean。首先，完全创建目标bean，然后再应用带有其拦截器链的AOP代理（例如）。如果目标bean和代理分别定义，通过传递代理你的代码也可以与原生目标bean交互。因此，将拦截器运用到<code>init</code>方法将是不一致的，因为这样做会将目标bean的声明周期与其代理、拦截器耦合到一起，并且当你的代码直接与原生目标bean交互式，会遗留下奇怪的语义</p>
<h4 id="Combining-lifecycle-mechanisms"><a href="#Combining-lifecycle-mechanisms" class="headerlink" title="Combining lifecycle mechanisms"></a>Combining lifecycle mechanisms</h4><p>结合声明周期机制</p>
<blockquote>
<p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior: the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener"><code>InitializingBean</code></a> and <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener"><code>DisposableBean</code></a> callback interfaces; custom <code>init()</code> and <code>destroy()</code> methods; and the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#beans-postconstruct-and-predestroy-annotations" target="_blank" rel="noopener"><code>@PostConstruct</code> and <code>@PreDestroy</code> annotations</a>. You can combine these mechanisms to control a given bean.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">as of... 在...时；从...起；自...使 （等价于 British English  as from ...）</span></pre></td></tr></table></figure>

<p>从Spring 2.5开始，有三种选择可以控制bean生命周期行为：<code>InitializingBean</code>和<code>DisposableBean</code>回调接口；自定义<code>init()</code>和<code>destroy()</code>方法以及<code>@PostConstruct</code>和<code>@PreDestroy</code>注解。你可以联合这些机制来控制给予的bean。</p>
<blockquote>
<p>If multiple lifecycle mechanisms are configured for a bean, and each mechanism is configured with a different method name, then each configured method is executed in the order listed below. However, if the same method name is configured - for example, <code>init()</code> for an initialization method - for more than one of these lifecycle mechanisms, that method is executed once, as explained in the preceding section.</p>
</blockquote>
<p>如果一个bean配置了多个生命周期机制，每种机制配置了不同的方法名，则配置的方法会以下面罗列的顺序执行。但是如果配置了相同的名称，例如，多个生命周期机制配置了相同的初始化方法<code>init()</code>，该方法将执行一次，如上一节所述。</p>
<blockquote>
<p>Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows:</p>
<ul>
<li>Methods annotated with <code>@PostConstruct</code></li>
<li><code>afterPropertiesSet()</code> as defined by the <code>InitializingBean</code> callback interface</li>
<li>A custom configured <code>init()</code> method</li>
</ul>
</blockquote>
<p>为同一个bean的多个生命周期配置了不同的初始化方法，将按照以下顺序调用：</p>
<ul>
<li><code>@PostConstruct</code>注解的方法</li>
<li><code>InitializingBean</code>回调接口定义的<code>afterPropertiesSet()</code></li>
<li>自定义配置的<code>init()</code>方法</li>
</ul>
<blockquote>
<p>Destroy methods are called in the same order:</p>
<ul>
<li>Methods annotated with <code>@PreDestroy</code></li>
<li><code>destroy()</code> as defined by the <code>DisposableBean</code> callback interface</li>
<li>A custom configured <code>destroy()</code> method</li>
</ul>
</blockquote>
<p>销毁方法以相同的顺序调用：</p>
<ul>
<li><code>@PreDestroy</code>注解方法</li>
<li><code>DisposableBean</code>回调接口定义的<code>destroy()</code></li>
<li>自定义的<code>destroy()</code></li>
</ul>
<h4 id="Startup-and-shutdown-callbacks"><a href="#Startup-and-shutdown-callbacks" class="headerlink" title="Startup and shutdown callbacks"></a>Startup and shutdown callbacks</h4><p>启动和关闭回调</p>
<blockquote>
<p>The <code>Lifecycle</code> interface defines the essential methods for any object that has its own lifecycle requirements (e.g. starts and stops some background process):</p>
</blockquote>
<p><code>Lifecycle</code>接口为具有自己生命周期需求的任意对象定义了基本的方法（例如，启动，停止一些后台进程）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Any Spring-managed object may implement that interface. Then, when the <code>ApplicationContext</code> itself receives start and stop signals, e.g. for a stop/restart scenario at runtime, it will cascade those calls to all <code>Lifecycle</code> implementations defined within that context. It does this by delegating to a <code>LifecycleProcessor</code>:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cascade(s) of 大量</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cascade n. 大量，许多；瀑布；v. 垂落，悬挂</span></pre></td></tr></table></figure>

<p>任何Spring管理的对象都可以实现该接口。然后，当<code>ApplicationContext</code>自身接收到启动和关闭信号时，例如，对于运行时的停止/重新启动场景，它将把这些调用级联到在该上下文中定义的所有生命周期实现。通过委托给<code>LifecycleProcessor</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleProcessor</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClose</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Notice that the <code>LifecycleProcessor</code> is itself an extension of the <code>Lifecycle</code> interface. It also adds two other methods for reacting to the context being refreshed and closed.</p>
</blockquote>
<p>注意，<code>LifecycleProcessor</code>本身扩展了<code>Lifecycle</code>接口。它也添加了其他两个方法<code>onRefresh()</code>和<code>onClose()</code>来对正在刷新的和关闭的<code>context</code>做出反应。</p>
<blockquote>
<p>Note that the regular <code>org.springframework.context.Lifecycle</code> interface is just a plain contract for explicit start/stop notifications and does NOT imply auto-startup at context refresh time. Consider implementing <code>org.springframework.context.SmartLifecycle</code> instead for fine-grained control over auto-startup of a specific bean (including startup phases). Also, please note that stop notifications are not guaranteed to come before destruction: On regular shutdown, all <code>Lifecycle</code> beans will first receive a stop notification before the general destruction callbacks are being propagated; however, on hot refresh during a context’s lifetime or on aborted refresh attempts, only destroy methods will be called.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">plain adj.普通的，平凡的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">contract n. 合同，契约</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">imply v. 暗示，暗指</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">notification n. 正式通知，正式通告</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">considered adj. 经过慎重思考的;经过深思熟虑的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">considering adj. 考虑到；就…而言；鉴于</span></pre></td></tr></table></figure>

<p>注意到常规的<code>org.springframework.context.Lifecycle</code>接口仅仅是显示启动关闭通知的简单约定，并不意味着在<code>context</code>刷新时会自动启动。考虑实现<code>org.springframework.contextSmartLifecycle</code>，对特定的bean实现更细粒度的自动启动控制（包括启动阶段）。请注意，不保证在销毁之前会发出停止通知：常规关闭时，所有的<code>Lifecycle</code>bean都会在传播一般销毁回调之前首先接收到停止通知。但是，在上下文生命周期内进行热刷新或刷新尝试失败时，只会调用destroy方法。</p>
<blockquote>
<p>The order of startup and shutdown invocations can be important. If a “depends-on” relationship exists between any two objects, the dependent side will start <em>after</em> its dependency, and it will stop <em>before</em> its dependency. However, at times the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type. In those cases, the <code>SmartLifecycle</code> interface defines another option, namely the <code>getPhase()</code> method as defined on its super-interface, <code>Phased</code>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">can be  可能</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">at times 有时</span></pre></td></tr></table></figure>

<p>启动关闭的调用顺序可能很重要。如果两个对象之间存在<code>depends-on</code>关系，则依赖方将在其依赖项后启动，并且在其依赖项之前停止。但是，存在直接依赖项是未知的。你仅能知道某种类型的对象应优先其他类型对象启动。在这些情况下，<code>org.springframework.context.SmartLifecycle</code>接口定义了另一个选择，定义在其超级接口<code>Phased</code>中<code>getPhase()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phased</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>When starting, the objects with the lowest phase start first, and when stopping, the reverse order is followed. Therefore, an object that implements <code>SmartLifecycle</code> and whose <code>getPhase()</code> method returns <code>Integer.MIN_VALUE</code> would be among the first to start and the last to stop. At the other end of the spectrum, a phase value of <code>Integer.MAX_VALUE</code> would indicate that the object should be started last and stopped first (likely because it depends on other processes to be running). When considering the phase value, it’s also important to know that the default phase for any “normal” <code>Lifecycle</code> object that does not implement <code>SmartLifecycle</code> would be 0. Therefore, any negative phase value would indicate that an object should start before those standard components (and stop after them), and vice versa for any positive phase value.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">at the other end of the spectrum  在另一方面；在另一个极端；与此形成对比；与此相反</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">spectrum n. 光谱；系列，范围</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">vice versa 反之亦然</span></pre></td></tr></table></figure>

<p>当启动的时候，最低阶段的对象首先启动，当停止时，遵循相反的顺序。因此，实现<code>SmartLifecycle</code>接口，并且其<code>getPhase()</code>方法返回<code>Integer.MIN_VALUE</code>将第一个启动且最后一个停止。另一方面，<code>Integer.MAX_VALUE</code>返回值的阶段表示，对象应该最后启动最先停止（可能因为它取决于其他将要运行的进程）。当考虑到<code>phase</code>的值，对于没有实现<code>SmartLifecycle</code>接口的任何正常<code>Lifecycle</code>对象的默认<code>phase</code>值为0，明白这点也很重要。因此，负值的<code>phase</code>表明一个对象应该在那些标准组件之前启动（在它们之后停止）， 反之亦然。</p>
<blockquote>
<p>As you can see the stop method defined by <code>SmartLifecycle</code> accepts a callback. Any implementation <em>must</em> invoke that callback’s <code>run()</code> method after that implementation’s shutdown process is complete. That enables asynchronous shutdown where necessary since the default implementation of the <code>LifecycleProcessor</code> interface, <code>DefaultLifecycleProcessor</code>, will wait up to its timeout value for the group of objects within each phase to invoke that callback. The default per-phase timeout is 30 seconds. You can override the default lifecycle processor instance by defining a bean named “lifecycleProcessor” within the context. If you only want to modify the timeout, then defining the following would be sufficient:</p>
</blockquote>
<p>可以看到，<code>SmartLifecycle</code>定义的<code>stop</code>方法接收一个回调。任何实现在其关闭进程完成之前都必须调用回调的<code>run()</code>方法。它启用了异步的关闭，这将在必要时启用异步关闭，因为<code>LifecycleProcessor</code>接口的默认实现<code>DefaultLifecycleProcessor</code>，等待每个阶段的对象组调用该回调，直到超时。每个阶段的默认超时时间为30s。你可以在上下文中通过定义一个名为<code>lifecycleProcessor</code>的bean重写默认<code>DefulatLifecycleProcessor</code>。如果仅仅希望修改超时时间，那么一下定义足够了：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"lifecycleProcessor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.support.DefaultLifecycleProcessor"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- timeout value in milliseconds --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeoutPerShutdownPhase"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>As mentioned, the <code>LifecycleProcessor</code> interface defines callback methods for the refreshing and closing of the context as well. The latter will simply drive the shutdown process as if <code>stop()</code> had been called explicitly, but it will happen when the context is closing. The ‘refresh’ callback on the other hand enables another feature of <code>SmartLifecycle</code> beans. When the context is refreshed (after all objects have been instantiated and initialized), that callback will be invoked, and at that point the default lifecycle processor will check the boolean value returned by each <code>SmartLifecycle</code> object’s <code>isAutoStartup()</code> method. If “true”, then that object will be started at that point rather than waiting for an explicit invocation of the context’s or its own <code>start()</code> method (unlike the context refresh, the context start does not happen automatically for a standard context implementation). The “phase” value as well as any “depends-on” relationships will determine the startup order in the same way as described above.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">as if  如果</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">on the other hand 另一方面</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">at that point 那时候</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">as well as ... 和 ... 一样</span></pre></td></tr></table></figure>

<p>如前所述，<code>LifecycleProcessor</code>接口定义了刷新<code>context</code>的方法，也定义关闭<code>context</code>的方法。如果显示调用<code>stop()</code>，后者仅驱动关闭进程，但是当<code>context</code>正在关闭时发生。另一方面<code>refresh</code>启用了<code>SmartLifecycle</code>bean的另一个功能。当<code>context</code>刷新（所有对象实例化和初始化后），回调将被调用，并且那时候默认的生命周期处理器将会检查<code>SmartLifecycle</code>对象的<code>isAutoStartup()</code>方法返回的布尔值。如果是<code>true</code>，对象将在那时候被启动而不是等待<code>context</code>或者自己的<code>start()</code>方法的显示调用（不像<code>context</code>刷新，对于一个标准的<code>context</code>实现，<code>context</code>不会自动启动）。<code>phase</code>值和任何<code>depends-on</code>关系一样，以上述描述的相同的方式决定启动顺序</p>
<h4 id="Shutting-down-the-Spring-IoC-container-gracefully-in-non-web-applications"><a href="#Shutting-down-the-Spring-IoC-container-gracefully-in-non-web-applications" class="headerlink" title="Shutting down the Spring IoC container gracefully in non-web applications"></a>Shutting down the Spring IoC container gracefully in non-web applications</h4><p>在非web应用中优雅地关闭Spring IoC 容器</p>
<blockquote>
<p>This section applies only to non-web applications. Spring’s web-based <code>ApplicationContext</code> implementations already have code in place to shut down the Spring IoC container gracefully when the relevant web application is shut down.</p>
</blockquote>
<p>该部分仅应用于非web应用。Spring基于web的<code>ApplicationContext</code>实现已经有适当的代码，可以在相关web应用关闭的时候关闭Spring IoC容器。</p>
<blockquote>
<p>If you are using Spring’s IoC container in a non-web application environment; for example, in a rich client desktop environment; you register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. Of course, you must still configure and implement these destroy callbacks correctly.</p>
</blockquote>
<p>如果你在非web环境中使用Spring IoC容器。例如，在福桌面环境；你注册了一个JVM关闭钩子方法。这样做可以确优雅地关闭和调用bean上的相关销毁方法，以至释放所有的资源。当然，你必须正确地配置和实现这些销毁方法。</p>
<blockquote>
<p>To register a shutdown hook, you call the <code>registerShutdownHook()</code> method that is declared on the <code>ConfigurableApplicationContext</code> interface:</p>
</blockquote>
<p>注册一个关闭钩子方法，你可以调用声明在<code>ConfigurableApplicationContext</code>接口中的<code>registerShutdownHook()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ConfigurableApplicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        ConfigurableApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// add a shutdown hook for the above context...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        ctx.registerShutdownHook();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// app runs here...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// main method exits, hook is called prior to the app shutting down...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="7-6-2-ApplicationContextAware-and-BeanNameAware"><a href="#7-6-2-ApplicationContextAware-and-BeanNameAware" class="headerlink" title="7.6.2 ApplicationContextAware and BeanNameAware"></a>7.6.2 ApplicationContextAware and BeanNameAware</h3><p><code>ApplicationContextAware</code>和<code>BeanNameAware</code>接口</p>
<blockquote>
<p>When an <code>ApplicationContext</code> creates an object instance that implements the <code>org.springframework.context.ApplicationContextAware</code> interface, the instance is provided with a reference to that <code>ApplicationContext</code>.</p>
</blockquote>
<p>当一个<code>ApplicationContext</code>创建了一个实现<code>org.springframework.context.ApplicationContextAware</code>接口的对象，该实例将获得一个<code>ApplicationContext</code>的引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Thus beans can manipulate programmatically the <code>ApplicationContext</code> that created them, through the <code>ApplicationContext</code> interface, or by casting the reference to a known subclass of this interface, such as <code>ConfigurableApplicationContext</code>, which exposes additional functionality. One use would be the programmatic retrieval of other beans. Sometimes this capability is useful; however, in general you should avoid it, because it couples the code to Spring and does not follow the Inversion of Control style, where collaborators are provided to beans as properties. Other methods of the <code>ApplicationContext</code> provide access to file resources, publishing application events, and accessing a <code>MessageSource</code>. These additional features are described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#context-introduction" target="_blank" rel="noopener">Section 7.15, “Additional capabilities of the ApplicationContext”</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">programmatically adv. 以编程方式;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">manipulate v. 摆布，操纵，控制(他人)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">functionality n. 功能  &#x3D; features</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">feature n. 特色，特征，特点；正片</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">expose v. 暴露，揭露</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">retrieval n. 检索；取回，找回 </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">capability n.能力，素质，力量</span></pre></td></tr></table></figure>

<p>因此bean可以控制创建它们的<code>ApplicationContext</code>, 通过<code>ApplicationContext</code>接口，或者将引用转换该接口的已知子类，比如<code>ConfigurableApplicationContext</code>，公开了额外的功能。一种用途就是通过编程方法检索其他bean。有时此功能很有用；但是，一般来说，应当避免，因为其将代码耦合到Spring并且没有遵循IoC风格，协作者作为属性提供给了bean。<code>ApplicationContext</code>接口的其他方法提供了对方法文件资源，发布应用实践和<code>MesssageSource</code>的访问。这些额外的功能将在7.15部分描述</p>
<blockquote>
<p>As of Spring 2.5, autowiring is another alternative to obtain reference to the <code>ApplicationContext</code>. The “traditional” <code>constructor</code> and <code>byType</code> autowiring modes (as described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#beans-factory-autowire" target="_blank" rel="noopener">Section 7.4.5, “Autowiring collaborators”</a>) can provide a dependency of type <code>ApplicationContext</code> for a constructor argument or setter method parameter, respectively. For more flexibility, including the ability to autowire fields and multiple parameter methods, use the new annotation-based autowiring features. If you do, the <code>ApplicationContext</code> is autowired into a field, constructor argument, or method parameter that is expecting the <code>ApplicationContext</code> type if the field, constructor, or method in question carries the <code>@Autowired</code> annotation. For more information, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#beans-autowired-annotation" target="_blank" rel="noopener">Section 7.9.2, “@Autowired”</a>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">respectively adv. 分别地，各自地</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">in question 被提及的; 讨论中的; 相关的;</span></pre></td></tr></table></figure>

<p>从Spring2.5开始，自动装备是取得对<code>ApplicationContext</code>应用的另一种选择。传统的构造方法和根据类型自动装备模式（7.4.5描述）分别为为构造方法参数或setter方法参数提供了<code>ApplicationContext</code>类型的依赖项。为了获得更大的灵活性，包括自动装备字段和多参数方法的能力，可以使用基于注解的自动装备功能。如果那样，可以将<code>ApplicationContext</code>自动装配到期望类型为<code>ApplicationContext</code>的一个字段，构造方法参数或者方法参数。</p>
<p>如果相关的字段，构造方法或方法带有<code>@Autowired</code>注解。更多信息请看7.9.2</p>
<blockquote>
<p>When an <code>ApplicationContext</code> creates a class that implements the <code>org.springframework.beans.factory.BeanNameAware</code> interface, the class is provided with a reference to the name defined in its associated object definition.</p>
</blockquote>
<p>当<code>ApplicationContext</code>创建了一个实现了<code>org.springframework.beans.factory.BeanNameAware</code>接口的类，该类将获得在其相关bean定义中定义的bean名称</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">public interface BeanNameAware &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    void setBeanName(String name) throws BeansException;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The callback is invoked after population of normal bean properties but before an initialization callback such as <code>InitializingBean</code> <em>afterPropertiesSet</em> or a custom init-method.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">population n. 填充（计）</span></pre></td></tr></table></figure>

<p>当正常bean属性填充后，但在一个初始化回调之前比如<code>InitializingBean</code>的<code>afterPropertiesSet()</code>或者自定义的<code>init-method</code>方法之后，调用回调</p>
<h3 id="7-6-3-Other-Aware-interfaces"><a href="#7-6-3-Other-Aware-interfaces" class="headerlink" title="7.6.3 Other Aware interfaces"></a>7.6.3 Other Aware interfaces</h3><blockquote>
<p>Besides <code>ApplicationContextAware</code> and <code>BeanNameAware</code> discussed above, Spring offers a range of <code>Aware</code> callback interfaces that allow beans to indicate to the container that they require a certain <em>infrastructure</em> dependency. The most important <code>Aware</code> interfaces are summarized below - as a general rule, the name is a good indication of the dependency type:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">a range of 一些列</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">summarize v. 总结</span></pre></td></tr></table></figure>

<p>除了上述讨论的<code>ApplicationContextAware</code>和<code>BeanNameAware</code>，Spring提供了一系列<code>Aware</code>回调接口，允许bean向容器指示他们需要某种基础依赖。最重要的<code>Aware</code>接口总结如下，作为一般规则，名称很好的表达了依赖项的类型。</p>
<p><strong>Table 7.4. Aware interfaces</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Injected Dependency</th>
</tr>
</thead>
<tbody><tr>
<td><code>ApplicationContextAware</code></td>
<td>Declaring <code>ApplicationContext</code></td>
</tr>
<tr>
<td><code>ApplicationEventPublisherAware</code></td>
<td>Event publisher of the enclosing <code>ApplicationContext</code></td>
</tr>
<tr>
<td><code>BeanClassLoaderAware</code></td>
<td>Class loader used to load the bean classes.</td>
</tr>
<tr>
<td><code>BeanFactoryAware</code></td>
<td>Declaring <code>BeanFactory</code></td>
</tr>
<tr>
<td><code>BeanNameAware</code></td>
<td>Name of the declaring bean</td>
</tr>
<tr>
<td><code>BootstrapContextAware</code></td>
<td>Resource adapter <code>BootstrapContext</code> the container runs in. Typically available only in JCA aware <code>ApplicationContext</code>s</td>
</tr>
<tr>
<td><code>LoadTimeWeaverAware</code></td>
<td>Defined <em>weaver</em> for processing class definition at load time</td>
</tr>
<tr>
<td><code>MessageSourceAware</code></td>
<td>Configured strategy for resolving messages (with support for parametrization and internationalization)</td>
</tr>
<tr>
<td><code>NotificationPublisherAware</code></td>
<td>Spring JMX notification publisher</td>
</tr>
<tr>
<td><code>PortletConfigAware</code></td>
<td>Current <code>PortletConfig</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code></td>
</tr>
<tr>
<td><code>PortletContextAware</code></td>
<td>Current <code>PortletContext</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code></td>
</tr>
<tr>
<td><code>ResourceLoaderAware</code></td>
<td>Configured loader for low-level access to resources</td>
</tr>
<tr>
<td><code>ServletConfigAware</code></td>
<td>Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code></td>
</tr>
<tr>
<td><code>ServletContextAware</code></td>
<td>Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring <code>ApplicationContext</code></td>
</tr>
</tbody></table>
<blockquote>
<p>Note again that usage of these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As such, they are recommended for infrastructure beans that require programmatic access to the container.</p>
</blockquote>
<p>再次注意，这些接口的使用将你的代码和Spring API绑定到了一起，且没有遵循IoC风格。因此，建议将它们用于需要使用以编程方式访问容器的基础架构bean。</p>
<h2 id="7-7-Bean-definition-inheritance"><a href="#7-7-Bean-definition-inheritance" class="headerlink" title="7.7 Bean definition inheritance"></a>7.7 Bean definition inheritance</h2><p>bean定义继承</p>
<blockquote>
<p>A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information such as initialization method, static factory method name, and so on. A child bean definition inherits configuration data from a parent definition. The child definition can override some values, or add others, as needed. Using parent and child bean definitions can save a lot of typing. Effectively, this is a form of templating.</p>
</blockquote>
<p>bean定义可以包含很多配置信息，包括构造方法参数，属性值和容器特定的信息比如初始化方法，静态工厂方法名称等等。子bean定义继承父bean定义的配置数据，子定义当需要时可以覆盖一些值，或者添加其他。使用父子bean定义可以节省很多输入。实际上，这是一种模板形式</p>
<blockquote>
<p>If you work with an <code>ApplicationContext</code> interface programmatically, child bean definitions are represented by the <code>ChildBeanDefinition</code> class. Most users do not work with them on this level, instead configuring bean definitions declaratively in something like the <code>ClassPathXmlApplicationContext</code>. When you use XML-based configuration metadata, you indicate a child bean definition by using the <code>parent</code> attribute, specifying the parent bean as the value of this attribute.</p>
</blockquote>
<p>如果你以编程的方式使用<code>ApplicationContext</code>接口，子bean定义由<code>ClildBeanDefinition</code>类表示。大部分用户在这个层次不会使用到它们，而是声明在像是<code>ClassPathXmlApplicationContext</code>配置bean定义。当你使用基于xml配置的元数据，通过使用<code>parent</code>属性来标识这是一个子bean定义，指定父bean为该属性的值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">abstract</span>=<span class="string">"true"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithDifferentClass"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- the age property value of 1 will be inherited from parent --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>A child bean definition uses the bean class from the parent definition if none is specified, but can also override it. In the latter case, the child bean class must be compatible with the parent, that is, it must accept the parent’s property values.</p>
</blockquote>
<p>如果未指定子bean定义，则使用父定义中bean类，但是也可以覆盖它。在后一种情况下，子bean类必须与父类兼容，也就是，他必须接受父类的属性值。</p>
<blockquote>
<p>A child bean definition inherits scope, constructor argument values, property values, and method overrides from the parent, with the option to add new values. Any scope, initialization method, destroy method, and/or <code>static</code> factory method settings that you specify will override the corresponding parent settings.</p>
</blockquote>
<p>子定义继承父定义作用域，可以选择添加新的值覆盖父类的构造方法参数值，属性值和方法。任何作用域，你指定的初始化方法，销毁方法，和或者静态工厂方法设置都将覆盖相应父类的设置</p>
<blockquote>
<p>The remaining settings are <em>always</em> taken from the child definition: <em>depends on</em>, <em>autowire mode</em>, <em>dependency check</em>, <em>singleton</em>, <em>lazy init</em>.</p>
</blockquote>
<p>其余设置总是从子定义获取：depend on, 自动装配模式， 依赖检查，单例，延迟初始化</p>
<blockquote>
<p>The preceding example explicitly marks the parent bean definition as abstract by using the <code>abstract</code> attribute. If the parent definition does not specify a class, explicitly marking the parent bean definition as <code>abstract</code> is required, as follows:</p>
</blockquote>
<p>上述例子使用<code>abstract</code>属性将父bean定义显示标记为抽象的。如果父定义没有指定一个类（没有指定<code>class</code>属性），则需要显示标记父bean定义为<code>abstract</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithClass"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">parent</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as <code>abstract</code>. When a definition is <code>abstract</code> like this, it is usable only as a pure template bean definition that serves as a parent definition for child definitions. Trying to use such an <code>abstract</code> parent bean on its own, by referring to it as a ref property of another bean or doing an explicit <code>getBean()</code> call with the parent bean id, returns an error. Similarly, the container’s internal <code>preInstantiateSingletons()</code> method ignores bean definitions that are defined as abstract.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">on one&#39;s own 单独地，独自地</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">serve as 用作;可当…使用;充作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">trying adj. 难对付的;令人厌烦的;令人恼火的</span></pre></td></tr></table></figure>

<p>父bean不能单独实例化因为它不完整，并且被显示标记为<code>abstract</code>。当一个定义是<code>abstract</code>,就像这个，它只能用于纯的模板定义，用于子定义的父定义。通过引用它作为另一个bean的引用属性，或者使用父bean的id显示调用<code>getBean()</code>方法，来尝试单独使用这样一个<code>abstract</code>父bean会返回一个错误。同样，容器内部的<code>preInstantiateSingletons()</code>方法忽略定义为抽象的bean定义。</p>
<blockquote>
<p><code>ApplicationContext</code> pre-instantiates all singletons by default. Therefore, it is important (at least for singleton beans) that if you have a (parent) bean definition which you intend to use only as a template, and this definition specifies a class, you must make sure to set the <em>abstract</em> attribute to <em>true</em>, otherwise the application context will actually (attempt to) pre-instantiate the <code>abstract</code> bean.</p>
</blockquote>
<p><code>ApplicationContext</code>默认预实例化所有单例。因此，如果你有一个仅想作为模板的（父）bean定义，这个定义指定了一个类，你必须确保<code>abstract</code>属性为<code>true</code>，这非常重要（至少对于单例），否则应用上下文实际将（尝试）预实例化<code>abstract</code>bean。</p>
<h2 id="7-8-Container-Extension-Points"><a href="#7-8-Container-Extension-Points" class="headerlink" title="7.8 Container Extension Points"></a>7.8 Container Extension Points</h2><p>容器扩展点</p>
<blockquote>
<p>Typically, an application developer does not need to subclass <code>ApplicationContext</code> implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. The next few sections describe these integration interfaces.</p>
</blockquote>
<p>通常情况下，应用开发者不需要子类化<code>ApplicationContext</code>实现类。相反，可以通过插入特殊集成接口的实现来扩展Spring IoC容器。</p>
<h3 id="7-8-1-Customizing-beans-using-a-BeanPostProcessor"><a href="#7-8-1-Customizing-beans-using-a-BeanPostProcessor" class="headerlink" title="7.8.1 Customizing beans using a BeanPostProcessor"></a>7.8.1 Customizing beans using a BeanPostProcessor</h3><p>使用<code>BeanPostProcessor</code>自定义bean</p>
<blockquote>
<p>The <code>BeanPostProcessor</code> interface defines <em>callback methods</em> that you can implement to provide your own (or override the container’s default) instantiation logic, dependency-resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom <code>BeanPostProcessor</code> implementations.</p>
</blockquote>
<p><code>BeanPostProcessor</code>接口定义了一些回调方法，你可以实现这些方法（覆盖容器默认的）提供自己的实例化逻辑，依赖解析逻辑等等。当Spring容器完成了实例化，配置，初始化一个bean后，如果你想实现一些自定义逻辑，可以接入一个或多个<code>BeanPostProcessor</code>实现</p>
<blockquote>
<p>You can configure multiple <code>BeanPostProcessor</code> instances, and you can control the order in which these <code>BeanPostProcessor</code>s execute by setting the <code>order</code> property. You can set this property only if the <code>BeanPostProcessor</code> implements the <code>Ordered</code> interface; if you write your own <code>BeanPostProcessor</code> you should consider implementing the <code>Ordered</code> interface too. For further details, consult the javadocs of the <code>BeanPostProcessor</code> and <code>Ordered</code> interfaces. See also the note below on <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-programmatically-registering-beanpostprocessors" target="_blank" rel="noopener">programmatic registration of <code>BeanPostProcessor</code>s</a>.</p>
</blockquote>
<p>你可以配置多个<code>BeanPostProcessor</code>实例，且可以通过设置<code>order</code>属性来控制执行<code>BeanPostProcessor</code>的执行顺序。仅当实现了<code>Ordered</code>接口时你可以设置这个属性。如果编写自己的<code>BeanPostProcessor</code>，应当考虑实现<code>Ordered</code>接口。有关更多详细信息，查阅<code>BeanPostProcessor</code>的javadoc和<code>Ordered</code>接口。也可以查看下面<code>BeanPostProcessor</code>程序化注册</p>
<blockquote>
<p><code>BeanPostProcessor</code>s operate on bean (or object) <em>instances</em>; that is to say, the Spring IoC container instantiates a bean instance and <em>then</em> <code>BeanPostProcessor</code>s do their work.</p>
<p><code>BeanPostProcessor</code>s are scoped <em>per-container</em>. This is only relevant if you are using container hierarchies. If you define a <code>BeanPostProcessor</code> in one container, it will <em>only</em> post-process the beans in that container. In other words, beans that are defined in one container are not post-processed by a <code>BeanPostProcessor</code> defined in another container, even if both containers are part of the same hierarchy.</p>
<p>To change the actual bean definition (i.e., the <em>blueprint</em> that defines the bean), you instead need to use a <code>BeanFactoryPostProcessor</code> as described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension-factory-postprocessors" target="_blank" rel="noopener">Section 7.8.2, “Customizing configuration metadata with a BeanFactoryPostProcessor”</a>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">blueprint n. 蓝图；计划；设想；构想</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">relevant adj. 相关的;相应的;有重要性的     适当的;合适的;确切的</span></pre></td></tr></table></figure>

<p><code>BeanPostProcessor</code>运行在bean或者对象实例上。也就是说，Spring IoC 容器实例化了一个bean实例，然后<code>BeanPostProcessor</code>运行。</p>
<p><code>BeanPostProcessor</code>的作用域是针对每个容器。仅在使用容器层次结构时才有意义。在容器中定义<code>BeanPostProcessor</code>，将仅对该容器的bean进行后处理。换句话说，一个容器中的bean不会被另一个容器中定义的<code>BeanPostProcessor</code>后处理，即使两个容器都是相同层次机构。</p>
<p>为了更改实际的bean定义（比如定义bean的蓝图），你需要使用<code>BeanFactoryPostProcessor</code>。</p>
<blockquote>
<p>The <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface consists of exactly two callback methods. When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both <em>before</em> container initialization methods (such as InitializingBean’s <em>afterPropertiesSet()</em> or any declared init method) are called as well as <em>after</em> any bean initialization callbacks. The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post-processor typically checks for callback interfaces or may wrap a bean with a proxy. Some Spring AOP infrastructure classes are implemented as bean post-processors in order to provide proxy-wrapping logic.</p>
</blockquote>
<p><code>org.springframework.beans.factory.config.BeanPostProcessor</code>接口完全由两个回调方法组成。当这样的类作为一个后置处理器注册到容器，对于每个由容器创建的bean，后处理器在调用容器初始化方法（例如<code>InitializingBean</code>的<code>afterPropertiesSet()</code>或任何声明的init方法）之前以及在任何bean初始化回调之后均从容器获得回调。后置处理器可以对bean实例执行任何操作，包括完全忽略回调。bean的后置处理器通常检查回调接口或者使用代理包装bean。为了实现代理包装逻辑，一些Spring AOP 基础架构类被实现为bean后置处理器</p>
<blockquote>
<p>An <code>ApplicationContext</code> <em>automatically detects</em> any beans that are defined in the configuration metadata which implement the <code>BeanPostProcessor</code> interface. The <code>ApplicationContext</code> registers these beans as post-processors so that they can be called later upon bean creation. Bean post-processors can be deployed in the container just like any other beans.</p>
</blockquote>
<p><code>ApplicationContext</code>自动检测定义在配置元数据中实现了<code>BeanPostProcessor</code>接口的bean。<code>ApplicationContext</code>将这些bean注册为后置处理器，使得他们在bean创建后被调用。bean后置处理器可以像任何其他bean一样部署到容器中。</p>
<blockquote>
<p>Note that when declaring a <code>BeanPostProcessor</code> using an <code>@Bean</code> factory method on a configuration class, the return type of the factory method should be the implementation class itself or at least the <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface, clearly indicating the post-processor nature of that bean. Otherwise, the <code>ApplicationContext</code> won’t be able to autodetect it by type before fully creating it. Since a <code>BeanPostProcessor</code> needs to be instantiated early in order to apply to the initialization of other beans in the context, this early type detection is critical.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">critical adj. 极其重要的关键的，至关重要的</span></pre></td></tr></table></figure>

<p>注意，在配置类中，当使用<code>@Bean</code>注解的工厂方法声明一个<code>BeanPostProcessor</code>时，工厂方法的返回类型应当是实现类本身，或者至少是<code>org.springframework.bean.factory.config.BeanPostProcessor</code>接口。明确表明了bean后置处理器的性质。否则，在创建它之前，<code>ApplicationContext</code>将不能根据类型自动检测。因为<code>BeanPostProcessor</code>需要早期实例化，以便于可以应用于context中其他bean的实例化，早期类型检测至关重要</p>
<blockquote>
<p>While the recommended approach for <code>BeanPostProcessor</code> registration is through <code>ApplicationContext</code> auto-detection (as described above), it is also possible to register them <em>programmatically</em> against a <code>ConfigurableBeanFactory</code> using the <code>addBeanPostProcessor</code> method. This can be useful when needing to evaluate conditional logic before registration, or even for copying bean post processors across contexts in a hierarchy. Note however that <code>BeanPostProcessor</code>s added programmatically <em>do not respect the <code>Ordered</code> interface</em>. Here it is the <em>order of registration</em> that dictates the order of execution. Note also that <code>BeanPostProcessor</code>s registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.</p>
</blockquote>
<p>建议通过<code>ApplicationContext</code>自动检测（如上描述）来注册<code>BeanPostProcessor</code>，也可以在<code>ConfigurableBeanFactory</code>中，以程序的方式使用<code>addBeanPostProcessor</code>方法。注册之前当需要评估条件逻辑时，这很有用，甚至在具有层次结构的上下文中，复制bean后置处理器。但是注意，以程序方式添加的<code>BeanPostProcessor</code>没有遵守<code>Ordered</code>接口约定。注册顺序就是执行的顺序。也需要注意，以程序注册的<code>BeanPostProcessor</code> 将在那些通过自动检测注册的<code>BeanPostProcessor</code>之前处理，而不考虑任任何显式的排序。</p>
<blockquote>
<p>Classes that implement the <code>BeanPostProcessor</code> interface are <em>special</em> and are treated differently by the container. All <code>BeanPostProcessor</code>s <em>and beans that they reference directly</em> are instantiated on startup, as part of the special startup phase of the <code>ApplicationContext</code>. Next, all <code>BeanPostProcessor</code>s are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto-proxying is implemented as a <code>BeanPostProcessor</code> itself, neither <code>BeanPostProcessor</code>s nor the beans they reference directly are eligible for auto-proxying, and thus do not have aspects woven into them.</p>
<p>For any such bean, you should see an informational log message: “<em>Bean foo is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</em>“.</p>
<p>Note that if you have beans wired into your <code>BeanPostProcessor</code> using autowiring or <code>@Resource</code> (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates, and therefore make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with <code>@Resource</code> where the field/setter name does not directly correspond to the declared name of a bean and no name attribute is used, then Spring will access other beans for matching them by type.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">eligible adj. 1. 有资格的;符合条件的;有能力的  2. （作为结婚对象）合适的，中意的</span></pre></td></tr></table></figure>



<p>实现了<code>BeanPostProcessor</code>接口的类是特殊的，并且被容器视为不同。作为<code>ApplicationContext</code>特殊启动阶段的一部分，所有的<code>BeanPostProcessor</code>和他们直接引用的bean在启动时被实例化。接下来，所有<code>BeanPostProcessor</code>以有序的方式注册且应用到容器中所有更晚的bean。因为AOP自动代理是作为<code>BeanPostProcessor</code>bean实现的，<code>BeanPostProcessor</code>和其直接依赖的bean都没有资格进行自动代理，因此也没有任何方面的可编织。</p>
<p>对于这样的bean，你应该可以看到log消息信息：”<em>Bean foo is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying)</em>“.</p>
<p>注意，如果你已经通过自动装配或者<code>@Resource</code>(可能降级为自动装配)将bean装配到<code>BeanPostProcessor</code>，当以类型匹配查找依赖候选项时，Spring可能会访问到预想不到的bean，因此让他们没有资格自动代理或者其他类型bean的后处理。例如，如果你有一个<code>@Resource</code>注解的依赖，其中字段和setter 名称没有直接与bean的名称相对应，并且没有使用<code>name</code>属性，那么Spring将按照类型匹配来访问其他bean。</p>
<blockquote>
<p>The following examples show how to write, register, and use <code>BeanPostProcessor</code>s in an <code>ApplicationContext</code>.</p>
</blockquote>
<p>下面例子展示了在<code>ApplicationContext</code>中，如何编写，注册和使用<code>BeanPostProcessor</code></p>
<h4 id="Example-Hello-World-BeanPostProcessor-style"><a href="#Example-Hello-World-BeanPostProcessor-style" class="headerlink" title="Example: Hello World, BeanPostProcessor-style"></a>Example: Hello World, BeanPostProcessor-style</h4><blockquote>
<p>This first example illustrates basic usage. The example shows a custom <code>BeanPostProcessor</code> implementation that invokes the <code>toString()</code> method of each bean as it is created by the container and prints the resulting string to the system console.</p>
</blockquote>
<p>第一个例子展示了基本的使用，下面的例子展示了一个自定义的<code>BeanPostProcessor</code>实现，它调用了容器创建的每个bean的<code>toString()</code>方法，并打印结果到控制台</p>
<blockquote>
<p>Find below the custom <code>BeanPostProcessor</code> implementation class definition:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> scripting;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstantiationTracingBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// simply return the instantiated bean as-is</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bean; <span class="comment">// we could potentially return any object reference here...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Bean '"</span> + beanName + <span class="string">"' created : "</span> + bean.toString());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> bean;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/lang</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/lang/spring-lang.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">lang:groovy</span> <span class="attr">id</span>=<span class="string">"messenger"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">            <span class="attr">script-source</span>=<span class="string">"classpath:org/springframework/scripting/groovy/Messenger.groovy"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">lang:property</span> <span class="attr">name</span>=<span class="string">"message"</span> <span class="attr">value</span>=<span class="string">"Fiona Apple Is Just So Dreamy."</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">lang:groovy</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    when the above bean (messenger) is instantiated, this custom</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    BeanPostProcessor implementation will output the fact to the system console</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">    --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"scripting.InstantiationTracingBeanPostProcessor"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Notice how the <code>InstantiationTracingBeanPostProcessor</code> is simply defined. It does not even have a name, and because it is a bean it can be dependency-injected just like any other bean. (The preceding configuration also defines a bean that is backed by a Groovy script. The Spring dynamic language support is detailed in the chapter entitled <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#dynamic-language" target="_blank" rel="noopener">Chapter 35, <em>Dynamic language support</em></a>.)</p>
</blockquote>
<p>注意到如何简单地定义<code>InstantiationTracingBeanPostPRocessor</code>。它甚至没有名字，且因为它是一个bean，可以像其他bean一样进行依赖注入。（之前的配置还定义了一个由<code>Groovy</code>脚本支持的bean）</p>
<blockquote>
<p>The following simple Java application executes the preceding code and configuration:</p>
</blockquote>
<p>下面简单的java应用程序执行了之前的代码和配置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.scripting.Messenger;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boot</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"scripting/beans.xml"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        Messenger messenger = (Messenger) ctx.getBean(<span class="string">"messenger"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        System.out.println(messenger);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The output of the preceding application resembles the following:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Bean 'messenger' created : [email protected]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">[email protected]</span></pre></td></tr></table></figure>

<h4 id="Example-The-RequiredAnnotationBeanPostProcessor"><a href="#Example-The-RequiredAnnotationBeanPostProcessor" class="headerlink" title="Example: The RequiredAnnotationBeanPostProcessor"></a>Example: The RequiredAnnotationBeanPostProcessor</h4><blockquote>
<p>Using callback interfaces or annotations in conjunction with a custom <code>BeanPostProcessor</code> implementation is a common means of extending the Spring IoC container. An example is Spring’s <code>RequiredAnnotationBeanPostProcessor</code> - a <code>BeanPostProcessor</code> implementation that ships with the Spring distribution which ensures that JavaBean properties on beans that are marked with an (arbitrary) annotation are actually (configured to be) dependency-injected with a value.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">in conjunction with ... 与...一起</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">common means 常用手段</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">ship v. 运送，运输</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">distribution n. 发行版本</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">arbitrary adj. 武断的，任意的，任性的，主观的</span></pre></td></tr></table></figure>

<p>使用回调接口与自定义的<code>BeanPostProcessor</code>实现一起是扩展Spring IoC容器的常用方法，一个例子就是Spring的<code>RequeiredAnnotationBeanPostProcessor</code>，一个<code>BeanPostProcessor</code>实现，该实现随着Spring发行版本一起提供，确保有（任意）注解的bean上的javaBean属性实际上是（被配置）依赖地注入了一个值</p>
<h3 id="7-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor"><a href="#7-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor" class="headerlink" title="7.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor"></a>7.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor</h3><p>使用<code>BeanFactoryPostProcessor</code>自定义配置元数据</p>
<blockquote>
<p>The next extension point that we will look at is the <code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>. The semantics of this interface are similar to those of the <code>BeanPostProcessor</code>, with one major difference: <code>BeanFactoryPostProcessor</code> operates on the <em>bean configuration metadata</em>; that is, the Spring IoC container allows a <code>BeanFactoryPostProcessor</code> to read the configuration metadata and potentially change it <em>before</em> the container instantiates any beans other than <code>BeanFactoryPostProcessor</code>s.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">extension point 扩展点</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">semantics n. 语义</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">major difference 主要区别</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">potentially adv. 潜在地，可能地</span></pre></td></tr></table></figure>

<p>下一个扩展点我们要看<code>ogr.springframework.bean.factory.config.BeanFactoryPostProcessor</code>。这个接口的语义和那些<code>BeanPostProcessor</code>相似，有一个主要的区别：<code>BeanFactoryPostProcessor</code>在bean的配置元数据上运行。也就是说，Spring IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据，并且可能在容器实例化除<code>BeanFactoryPostProcessor</code>之外bean之前对其进行更改</p>
<blockquote>
<p>You can configure multiple <code>BeanFactoryPostProcessor</code>s, and you can control the order in which these <code>BeanFactoryPostProcessor</code>s execute by setting the <code>order</code> property. However, you can only set this property if the <code>BeanFactoryPostProcessor</code> implements the <code>Ordered</code> interface. If you write your own <code>BeanFactoryPostProcessor</code>, you should consider implementing the <code>Ordered</code> interface too. Consult the javadocs of the <code>BeanFactoryPostProcessor</code> and <code>Ordered</code> interfaces for more details.</p>
</blockquote>
<p>你可以配置多个<code>BeanFactoryPostProcessor</code>，并通过设置<code>order</code>属性来控制<code>BeanFactoryPostProcessor</code>的执行顺序。</p>
<blockquote>
<p>If you want to change the actual bean <em>instances</em> (i.e., the objects that are created from the configuration metadata), then you instead need to use a <code>BeanPostProcessor</code> (described above in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp" target="_blank" rel="noopener">Section 7.8.1, “Customizing beans using a BeanPostProcessor”</a>). While it is technically possible to work with bean instances within a <code>BeanFactoryPostProcessor</code> (e.g., using <code>BeanFactory.getBean()</code>), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects such as bypassing bean post processing.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">technically adv. 严格来说，准确来说</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">premature adj. 过早的，太早的，提前的；不成熟的，草率的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">violate v. 违反，违背，违犯（协议、法律或承诺）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">side effect 副作用</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">bypass v. 绕过，避开，越过</span></pre></td></tr></table></figure>

<p>如果想更改实际的bean实例（比如，由配置元数据创建的对象），你需要使用<code>BeanPostProcessor</code>。虽然严格来说可以在<code>BeanFacotryPostProcessor</code>里使用bean实例（例如使用<code>BeanFactory.getBean()</code>），但这样做会导致bean过早实例化，违反了标准容器的生命周期。这可能会导致负面影响，例如绕过bean后处理</p>
<blockquote>
<p>Also, <code>BeanFactoryPostProcessor</code>s are scoped <em>per-container</em>. This is only relevant if you are using container hierarchies. If you define a <code>BeanFactoryPostProcessor</code> in one container, it will <em>only</em> be applied to the bean definitions in that container. Bean definitions in one container will not be post-processed by <code>BeanFactoryPostProcessor</code>s in another container, even if both containers are part of the same hierarchy.</p>
</blockquote>
<p>而且，<code>BeanFactoryPostProcessor</code>的作用域是针对每个容器的。仅在使用容器层次结构时才有意义。如果在一个容器中定义了<code>BeanFactoryPostProcessor</code>，它只会应用那个容器的bean定义。一个容器中的bean定义不会被其他容器中的<code>BeanFactoryPostProcessor</code>后处理，即使两个容器都是同一层次的一部分</p>
<blockquote>
<p>A bean factory post-processor is executed automatically when it is declared inside an <code>ApplicationContext</code>, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as <code>PropertyOverrideConfigurer</code> and <code>PropertyPlaceholderConfigurer</code>. A custom <code>BeanFactoryPostProcessor</code> can also be used, for example, to register custom property editors.</p>
</blockquote>
<p>声明在<code>ApplicationContext</code>中的<code>BeanFactoryPostProcessor</code>会自动执行，以便将更改应用于定义容器的元数据。Spring包含了大量的预定义<code>BeanFactoryPostProcessor</code>，比如<code>PropertyOverrideConfigurer</code>和<code>PropertyPlaceholderConfigurer</code>。可以使用自定义的<code>BeanFactoryPostProcessor</code>，例如，注册自定义的属性编辑器</p>
<blockquote>
<p>An <code>ApplicationContext</code> automatically detects any beans that are deployed into it that implement the <code>BeanFactoryPostProcessor</code> interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.</p>
</blockquote>
<p><code>ApplicationContext</code>自动检测部署到其中的所有实现了<code>BeanFactoryPostProcessor</code>接口的bean。适当的时机，它将这些bean用作<code>BeanFactoryPostProcessor</code>，您可以像部署其他任何bean一样部署这些后处理器bean。</p>
<blockquote>
<p>As with <code>BeanPostProcessor</code>s , you typically do not want to configure <code>BeanFactoryPostProcessor</code>s for lazy initialization. If no other bean references a <code>Bean(Factory)PostProcessor</code>, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the <code>Bean(Factory)PostProcessor</code> will be instantiated eagerly even if you set the <code>default-lazy-init</code> attribute to <code>true</code> on the declaration of your <code>&lt;beans/&gt;</code> element.</p>
</blockquote>
<p>与<code>BeanPostProcessor</code>，通常你不想配置延迟初始化<code>BeanFactoryPostProcessor</code>。如果没有其他bean引用<code>Bean(Factory)PostProcessor</code>，那么后置处理器完全不会被实例化。因此，将其标记为延迟实例化将被忽略，并且<code>Bean(Factory)PostProcessor</code>会过早的实例化即使你设置<code>&lt;beans/&gt;</code>元素上的<code>default-lazy-init</code>属性为<code>true</code>。</p>
<h4 id="Example-the-Class-name-substitution-PropertyPlaceholderConfigurer"><a href="#Example-the-Class-name-substitution-PropertyPlaceholderConfigurer" class="headerlink" title="Example: the Class name substitution PropertyPlaceholderConfigurer"></a>Example: the Class name substitution PropertyPlaceholderConfigurer</h4><p>类名替换？</p>
<blockquote>
<p>You use the <code>PropertyPlaceholderConfigurer</code> to externalize property values from a bean definition in a separate file using the standard Java <code>Properties</code> format. Doing so enables the person deploying an application to customize environment-specific properties such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">externalize v. 表露，公开表达</span></pre></td></tr></table></figure>

<p>使用标准的Java属性格式，通过<code>PropertyPlaceholderConfigurer</code>将在单独文件中bean定义的属性值表示出来。这样做使应用部署人员可以自定义特定环境属性，比如数据库<code>URL</code>和密码，而没有修改容器的主要xml定义文件的复杂或风险。</p>
<blockquote>
<p>Consider the following XML-based configuration metadata fragment, where a <code>DataSource</code> with placeholder values is defined. The example shows properties configured from an external <code>Properties</code> file. At runtime, a <code>PropertyPlaceholderConfigurer</code> is applied to the metadata that will replace some properties of the DataSource. The values to replace are specified as <em>placeholders</em> of the form <code>${property-name}</code> which follows the Ant / log4j / JSP EL style.</p>
</blockquote>
<p>考虑下列基于xml的配置元数据片段，其中定义了带有<code>placeholder</code>值的<code>DataSource</code>。例子表明了从外部属性文件配置的属性。运行时，<code>PropertyPlaceholderConfigurer</code>应用于替换<code>DataSource</code>的某些属性值的元数据。替换的值以<code>${property-name}</code>的形式，作为<code>placeholder</code>指定，其遵循Ant/log4j/JSP EL风格</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span> <span class="attr">value</span>=<span class="string">"classpath:com/foo/jdbc.properties"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The actual values come from another file in the standard Java <code>Properties</code> format:</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">org.hsqldb.jdbcDriver</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:hsqldb:hsql://production:9002</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.username</span>=<span class="string">sa</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.password</span>=<span class="string">root</span></span></pre></td></tr></table></figure>

<blockquote>
<p>Therefore, the string <code>${jdbc.username}</code> is replaced at runtime with the value ‘sa’, and the same applies for other placeholder values that match keys in the properties file. The <code>PropertyPlaceholderConfigurer</code> checks for placeholders in most properties and attributes of a bean definition. Furthermore, the placeholder prefix and suffix can be customized.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">furthermore 而且;此外;再者</span></pre></td></tr></table></figure>

<p>因此，字符串<code>${jdbc.username}</code>在运行时被值sa替换，也同样应用与其他匹配属性文件中键的<code>placeholder</code>值。<code>PropertyPlaceholderConfigurer</code>检查bean定义的大多数属性和属性中的占位符。而且，可以自定义<code>placeholder</code>前缀和后缀。</p>
<blockquote>
<p>With the <code>context</code> namespace introduced in Spring 2.5, it is possible to configure property placeholders with a dedicated configuration element. One or more locations can be provided as a comma-separated list in the <code>location</code> attribute.</p>
</blockquote>
<p>随着Spring2.5 <code>context</code>命名空间的引入，有可能使用专门的配置元素来配置属性<code>placeholder</code>。在<code>location</code>属性中可以提供一个或者多个以逗号隔开的location。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:com/foo/jdbc.properties"</span>/&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>PropertyPlaceholderConfigurer</code> not only looks for properties in the <code>Properties</code> file you specify. By default it also checks against the Java <code>System</code> properties if it cannot find a property in the specified properties files. You can customize this behavior by setting the <code>systemPropertiesMode</code> property of the configurer with one of the following three supported integer values:</p>
<ul>
<li><em>never</em> (0): Never check system properties</li>
<li><em>fallback</em> (1): Check system properties if not resolvable in the specified properties files. This is the default.</li>
<li><em>override</em> (2): Check system properties first, before trying the specified properties files. This allows system properties to override any other property source.</li>
</ul>
</blockquote>
<p><code>PropertyPlaceholderConfigurer</code>不仅属性文件中所指定的属性。默认地，如果在指定的属性文件中没有找到相应属性，它也检查java系统属性。可以通过设置配置器的<code>systemPropertiesMode</code>属性来自定义这种行为，支持以下三种支持integer值的一种：</p>
<ul>
<li>never 0 ：从不检查系统属性</li>
<li>fallback 1 ：默认，如果指定的属性文件不能解析，则检查系统属性</li>
<li>override 2 ：在尝试解析执行配置文件之前，首先检查系统属性。这允许系统属性覆盖任何其他属性源。</li>
</ul>
<blockquote>
<p>Consult the <code>PropertyPlaceholderConfigurer</code> javadocs for more information.</p>
</blockquote>
<p>查看更多关于<code>PropertyPlaceholderConfigurer</code>javadocs</p>
<blockquote>
<p>You can use the <code>PropertyPlaceholderConfigurer</code> to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. For example:    subsitute v.  用…代替;取代;替换</p>
<p>可以使用<code>PropertyPlaceholderConfigurer</code>来替带类名，当你运行时不得不去选择一个特定的实现类的时候，这时特别有用。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:com/foo/strategy.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">value</span>&gt;</span>custom.strategy.class=com.foo.DefaultStrategy<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&gt;<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceStrategy"</span> <span class="attr">class</span>=<span class="string">"$&#123;custom.strategy.class&#125;"</span>/&gt;</span></span></pre></td></tr></table></figure>

<p>If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the <code>preInstantiateSingletons()</code> phase of an <code>ApplicationContext</code> for a non-lazy-init bean.</p>
<p>如果运行时类名没有被解析为有效的类，则要创建bean的解析会失败，也就是在非延迟初始化bean的<code>ApplicationContext</code>的<code>preInstantiateSingletons()</code>阶段进行的。</p>
</blockquote>
<h4 id="Example-the-PropertyOverrideConfigurer"><a href="#Example-the-PropertyOverrideConfigurer" class="headerlink" title="Example: the PropertyOverrideConfigurer"></a>Example: the PropertyOverrideConfigurer</h4><p>覆盖属性配置器</p>
<blockquote>
<p>The <code>PropertyOverrideConfigurer</code>, another bean factory post-processor, resembles the <code>PropertyPlaceholderConfigurer</code>, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding <code>Properties</code> file does not have an entry for a certain bean property, the default context definition is used.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ressemble v. 类似;与…相似;与…相像</span></pre></td></tr></table></figure>

<p><code>PropertyOverrideConfigurer</code>，另一个bean工厂后置处理器，与<code>PropertyPlaceholderConfigurer</code>，但是不像后者，源bean定义可以具有默认值或者所有bean属性都没有值。如果一个覆盖的属性文件没有某个bean属性的条目，则使用默认的上下文定义。</p>
<blockquote>
<p>Note that the bean definition is <em>not</em> aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple <code>PropertyOverrideConfigurer</code> instances that define different values for the same bean property, the last one wins, due to the overriding mechanism.</p>
</blockquote>
<p>注意，bean定义不知道其会被覆盖，因此从xml定义文件中不能立即明显看出正在使用覆盖配置器。如果有多个<code>PropertyOverrideOnfigurer</code>实例为同一个bean属性定义了不同的值，由于覆盖机制，最后一个将获胜。</p>
<blockquote>
<p>Properties file configuration lines take this format:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">beanName.property&#x3D;value</span></pre></td></tr></table></figure>

<blockquote>
<p>For example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">dataSource.driverClassName&#x3D;com.mysql.jdbc.Driver</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dataSource.url&#x3D;jdbc:mysql:mydb</span></pre></td></tr></table></figure>

<blockquote>
<p>This example file can be used with a container definition that contains a bean called <em>dataSource</em>, which has <em>driver</em> and <em>url</em> properties.</p>
</blockquote>
<blockquote>
<p>Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null (presumably initialized by the constructors). In this example…</p>
</blockquote>
<p>只要路径的每个组成部分（最终属性被覆盖）之外的所有组成部分都已经为非空（可能是由构造函数初始化），则也支持复合属性名。 在这个例子中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">presumably adv. 大概；很可能；也许；据推测</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">as long as  只要</span></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">foo.fred.bob.sammy&#x3D;123</span></pre></td></tr></table></figure>

<h3 id="7-8-3-Customizing-instantiation-logic-with-a-FactoryBean"><a href="#7-8-3-Customizing-instantiation-logic-with-a-FactoryBean" class="headerlink" title="7.8.3 Customizing instantiation logic with a FactoryBean"></a>7.8.3 Customizing instantiation logic with a FactoryBean</h3><p>使用<code>FactoryBean</code>自定义初始化逻辑</p>
<blockquote>
<p>Implement the <code>org.springframework.beans.factory.FactoryBean</code> interface for objects that <em>are themselves factories</em>.</p>
</blockquote>
<p>为对象实现它们自己工厂的<code>org.springframework.beans.factory.FactoryBean</code>接口</p>
<blockquote>
<p>The <code>FactoryBean</code> interface is a point of pluggability into the Spring IoC container’s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own <code>FactoryBean</code>, write the complex initialization inside that class, and then plug your custom <code>FactoryBean</code> into the container.</p>
</blockquote>
<p><code>FactoryBean</code>接口是一个扩展Spring IoC容器实例化逻辑的扩展点。如果你具有复杂的初始化代码，使用java代码可以更好的表达，你可以创建自己的<code>FactoryBean</code>，在该类中编写复杂的初始化，将自定义的<code>FactoryBean</code>纳入容器。</p>
<blockquote>
<p>The <code>FactoryBean</code> interface provides three methods:</p>
<ul>
<li><code>Object getObject()</code>: returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes.</li>
<li><code>boolean isSingleton()</code>: returns <code>true</code> if this <code>FactoryBean</code> returns singletons, <code>false</code> otherwise.</li>
<li><code>Class getObjectType()</code>: returns the object type returned by the <code>getObject()</code> method or <code>null</code> if the type is not known in advance.</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">in advance 事先，预先</span></pre></td></tr></table></figure>



<p><code>FactoryBean</code>接口提供了三个接口：</p>
<ul>
<li><code>Object getObject()</code>：返回该工厂创建对象的实例。该实例可被共享，取决于工厂返回单例还是原型类型</li>
<li><code>boolean isSingleton()</code>： 返回<code>true</code>，工厂返回单例</li>
<li><code>Class getObjectType()</code>：返回由<code>getObject()</code>方法返回对象的类型，或者<code>null</code>如果类型未知</li>
</ul>
<blockquote>
<p>The <code>FactoryBean</code> concept and interface is used in a number of places within the Spring Framework; more than 50 implementations of the <code>FactoryBean</code> interface ship with Spring itself.</p>
</blockquote>
<p><code>FactoryBean</code>概念和接口被用于Spring框架的很多地方。随Spring本身一起，超过50个<code>FactoryBean</code>的实现。</p>
<blockquote>
<p>When you need to ask a container for an actual <code>FactoryBean</code> instance itself instead of the bean it produces, preface the bean’s id with the ampersand symbol ( <code>&amp;</code>) when calling the <code>getBean()</code> method of the <code>ApplicationContext</code>. So for a given <code>FactoryBean</code> with an id of <code>myBean</code>, invoking <code>getBean(&quot;myBean&quot;)</code> on the container returns the product of the <code>FactoryBean</code>; whereas, invoking <code>getBean(&quot;&amp;myBean&quot;)</code> returns the <code>FactoryBean</code> instance itself.   </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">whereas adv. (表示对比)但是，然而</span></pre></td></tr></table></figure>

<p>当需要想容器请求一个实际的<code>FactoryBean</code>实例本身，而不是它所创建的bean时，请在调用<code>ApplicationContext</code>的<code>getBean()</code>方法时在该bean的ID前面加上一个＆符（＆）。因此对给定的id为<code>myBean</code>的<code>FactoryBean</code>，调用容器的<code>getBean(&quot;myBean&quot;)</code>返回<code>FactoryBean</code>创建的bean。但是，调用<code>getBean(&quot;&amp;myBean&quot;)</code>返回<code>FactoryBean</code>实例本身。</p>
<h2 id="7-9-Annotation-based-container-configuration"><a href="#7-9-Annotation-based-container-configuration" class="headerlink" title="7.9 Annotation-based container configuration"></a>7.9 Annotation-based container configuration</h2><p>基于注解的容器配置</p>
<blockquote>
<p><strong>Are annotations better than XML for configuring Spring?</strong></p>
<p>The introduction of annotation-based configurations raised the question of whether this approach is ‘better’ than XML. The short answer is <em>it depends</em>. The long answer is that each approach has its pros and cons, and usually it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.</p>
<p>No matter the choice, Spring can accommodate both styles and even mix them together. It’s worth pointing out that through its <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-java" target="_blank" rel="noopener">JavaConfig</a> option, Spring allows annotations to be used in a non-invasive way, without touching the target components source code and that in terms of tooling, all configuration styles are supported by the <a href="https://spring.io/tools/sts" target="_blank" rel="noopener">Spring Tool Suite</a>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pros and cons 利弊</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">it is up to </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">excel v. 突出;擅长;胜过（他人）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">accommodate v. （有足够的空间）容纳，接纳</span></pre></td></tr></table></figure>



<p>配置Spring，注解优于XML？</p>
<p>基于注解配置的引入提出了一个问题，这种方法是否比XML更好。简单回答就是看情况。长的回答是，每种方法都有其优缺点，并且通常来说要看开发者决定哪种策略更适合他们。由于定义他们的方式，注解在其声明中提供了很多<code>context</code>，从而配置更简短更简洁。但是，xml擅长在没有触碰其源码的情况下装配组件，或者将它们重新编译。一些开发者更喜欢基于源码的装配，而其他人认为带有注解的类不再是POJO，并且，进一步说，配置变的分散且难以控制。</p>
<p>无论选择如何，Spring都可以容纳两种风格，且一起混合使用。值得指出，尽管javaConfig的选择，Spring允许以非侵入式的方式来使用注解，无需接触组件源码，并在工具方面，所有的配置风格都被Spring Tool Suite支持。</p>
<blockquote>
<p>An alternative to XML setups is provided by annotation-based configuration which rely on the bytecode metadata for wiring up components instead of angle-bracket declarations. Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration. As mentioned in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp-examples-rabpp" target="_blank" rel="noopener">the section called “Example: The RequiredAnnotationBeanPostProcessor”</a>, using a <code>BeanPostProcessor</code> in conjunction with annotations is a common means of extending the Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing required properties with the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-required-annotation" target="_blank" rel="noopener">@Required</a> annotation. Spring 2.5 made it possible to follow that same general approach to drive Spring’s dependency injection. Essentially, the <code>@Autowired</code> annotation provides the same capabilities as described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-autowire" target="_blank" rel="noopener">Section 7.4.5, “Autowiring collaborators”</a> but with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250 annotations such as <code>@PostConstruct</code>, and <code>@PreDestroy</code>. Spring 3.0 added support for JSR-330 (Dependency Injection for Java) annotations contained in the javax.inject package such as <code>@Inject</code> and <code>@Named</code>. Details about those annotations can be found in the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-standard-annotations" target="_blank" rel="noopener">relevant section</a>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">angle-bracket 尖括号，大括号</span></pre></td></tr></table></figure>

<p>基于注解的配置提供了xml配置的一种替代方法，改配置依赖字节码元数据装配组件而不是尖括号声明。代替使用xml来描述bean的装配，开发者可以使用在相关类上，方法上，域上的注解将配置移入配置类本身。如在<a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp-examples-rabpp" target="_blank" rel="noopener">the section called “Example: The RequiredAnnotationBeanPostProcessor”</a>提到的，使用<code>BeanPostProcessor</code>和注解一起来扩展Spring IoC容器的通用方法。例如，Spring2.0引入了使用<code>@Required</code>注解强制必须的属性的可能。Spring 2.5使遵循相同的通用方法来驱动Spring的依赖注入成为可能。本质上，<code>@Autowired</code>注解提供了7.4.5部分描述的相同的功能，但有更细粒度的控制，更广的适用性。Spring2.5 也添加了对JSR250注解的支持，比如<code>@PostConstruct</code>和<code>@PreDestroy</code>。Spring3.0添加了对JSR30(java依赖注入)注解的支持，在java.inject.包下例如<code>@Inject</code>和<code>@Name</code>。更多关于这些注解的细节可靠相关部分。</p>
<blockquote>
<p>Annotation injection is performed <em>before</em> XML injection, thus the latter configuration will override the former for properties wired through both approaches.</p>
</blockquote>
<p>注解注入是在xml注入之前进行的，所以使用两种方法装配的属性，后者的配置会覆盖前者的</p>
<blockquote>
<p>As always, you can register them as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the <code>context</code> namespace):</p>
</blockquote>
<p>与往常一样，您可以将它们注册为单独的bean定义，但是也可以通过在基于XML的Spring配置中包含以下标记来隐式注册它们（请注意包含<code>context</code>名称空间）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>(The implicitly registered post-processors include <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>AutowiredAnnotationBeanPostProcessor</code></a>, <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>CommonAnnotationBeanPostProcessor</code></a>, <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>PersistenceAnnotationBeanPostProcessor</code></a>, as well as the aforementioned <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html" target="_blank" rel="noopener"><code>RequiredAnnotationBeanPostProcessor</code></a>.)</p>
</blockquote>
<p><code>&lt;context:annotation-config/&gt;</code>作用：隐式注册后置处理器包括<code>AutowiredAnnotationBeanProcessor</code>, <code>CommonAnnotationBeanPostProcessor</code>，<code>PersistenceAnnotationBeanPostProcessor</code>，和之前提到的<code>RequiredAnnotationBeanPostProcessor</code></p>
<blockquote>
<p><code>&lt;context:annotation-config/&gt;</code> only looks for annotations on beans in the same application context in which it is defined. This means that, if you put <code>&lt;context:annotation-config/&gt;</code> in a <code>WebApplicationContext</code> for a <code>DispatcherServlet</code>, it only checks for <code>@Autowired</code> beans in your controllers, and not your services. See <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#mvc-servlet" target="_blank" rel="noopener">Section 22.2, “The DispatcherServlet”</a> for more information.</p>
</blockquote>
<p><code>&lt;context:annotation-config/&gt;</code>仅查找相同<code>context</code>定义的bean上的注解。也就是说，如果你把<code>&lt;context:annotation-config/&gt;</code>放入<code>WebApplicationContext</code>或者<code>DispatcherServlet</code>，它仅检查你控制器中<code>@Autowired</code>注解的bean，而没有你的service</p>
<h3 id="7-9-1-Required"><a href="#7-9-1-Required" class="headerlink" title="7.9.1 @Required"></a>7.9.1 @Required</h3><blockquote>
<p>The <code>@Required</code> annotation applies to bean property setter methods, as in the following example:</p>
</blockquote>
<p><code>@Required</code>注解应用于bean属性的setter方法，如下例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Required</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>This annotation simply indicates that the affected bean property must be populated at configuration time, through an explicit property value in a bean definition or through autowiring. The container throws an exception if the affected bean property has not been populated; this allows for eager and explicit failure, avoiding <code>NullPointerException</code>s or the like later on. It is still recommended that you put assertions into the bean class itself, for example, into an init method. Doing so enforces those required references and values even when you use the class outside of a container.</p>
</blockquote>
<p>该注释仅表明必须在配置时通过bean定义中的显式属性值或通过自动装配来填充受影响的bean属性。 如果受影响的ben属性没有被填充，容器将抛出异常。允许的这种急切和显式的失败，避免<code>NullPointerException</code>或后续之类的东西。仍然建议你将断言放入bean类本身中，例如放到一个<code>init</code>方法。这样做可以强制那些必须的引用和值，即使在容器外部使用该类。</p>
<h3 id="7-9-2-Autowired"><a href="#7-9-2-Autowired" class="headerlink" title="7.9.2 @Autowired"></a>7.9.2 @Autowired</h3><blockquote>
<p>JSR 330’s <code>@Inject</code> annotation can be used in place of Spring’s <code>@Autowired</code> annotation in the examples below. See <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-standard-annotations" target="_blank" rel="noopener">here</a> for more details.</p>
</blockquote>
<p>使用JSR330的<code>@Inject</code>注解可以代替Spring中<code>@Autowired</code>注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>As of Spring Framework 4.3, an <code>@Autowired</code> annotation on such a constructor is no longer necessary if the target bean only defines one constructor to begin with. However, if several constructors are available, at least one must be annotated to teach the container which one to use.</p>
</blockquote>
<p>从Spring 4.3开始，如果目标bean仅定义了一个以<code>@Autowired</code>开始的构造方法，<code>@Autowired</code>注解不在必须，可以省略</p>
<blockquote>
<p>As expected, you can also apply the <code>@Autowired</code> annotation to “traditional” setter methods:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>You can also apply the annotation to methods with arbitrary names and/or multiple arguments:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(MovieCatalog movieCatalog,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">            CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>You can apply <code>@Autowired</code> to fields as well and even mix it with constructors:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CustomerPreferenceDao customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">(CustomerPreferenceDao customerPreferenceDao)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Make sure that your target components (e.g. <code>MovieCatalog</code>, <code>CustomerPreferenceDao</code>) are consistently declared by the type that you are using for your <code>@Autowired</code>-annotated injection points. Otherwise injection may fail due to no type match found at runtime.</p>
<p>For XML-defined beans or component classes found through a classpath scan, the container usually knows the concrete type upfront. However, for <code>@Bean</code> factory methods, you need to make sure that the declared return type is sufficiently expressive. For components implementing several interfaces or for components potentially referred to by their implementation type, consider declaring the most specific return type on your factory method (at least as specific as required by the injection points referring to your bean).</p>
</blockquote>
<p>确保目标组件(比如<code>MovieCatalog</code>，<code>CustomerPreferenceDao</code>)使用<code>@Autowired</code>一致地基于类型的声明，否则可能由于在运行时找不到匹配的类型而失败。</p>
<p>对于通过类路径扫描xml定义的bean或者组件类，容器通常预先知道具体的类型，对于<code>@Bean</code>工厂方法，你需要确保声明的返回值类型是足够表达的。对于实现好几个接口的组件或者可能基于他们的实现类型引用的组件，请考虑在工厂方法声明最具体的返回类型（at least as specific as required by the injection points referring to your bean）</p>
<blockquote>
<p>It is also possible to provide <em>all</em> beans of a particular type from the <code>ApplicationContext</code> by adding the annotation to a field or method that expects an array of that type:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog[] movieCatalogs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The same applies for typed collections:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Set&lt;MovieCatalog&gt; movieCatalogs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Set&lt;MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Your target beans can implement the <code>org.springframework.core.Ordered</code> interface or use the <code>@Order</code> or standard <code>@Priority</code> annotation if you want items in the array or list to be sorted in a specific order. Otherwise their order will follow the registration order of the corresponding target bean definitions in the container.</p>
</blockquote>
<p>如果想让数组，列表中的条目按照指定的顺序排序，目标bean可以实现<code>org.springframework.core.Ordered</code>接口或者使用<code>@Order</code>或者标准的<code>@Primary</code>注解。否则，它们将遵循相应目标bean定义在容器中注册顺序。</p>
<blockquote>
<p>The <code>@Order</code> annotation may be declared at target class level but also on <code>@Bean</code> methods, potentially being very individual per bean definition (in case of multiple definitions with the same bean class). <code>@Order</code> values may influence priorities at injection points, but please be aware that they do not influence singleton startup order which is an orthogonal concern determined by dependency relationships and <code>@DependsOn</code> declarations.</p>
</blockquote>
<p><code>@Order</code>注解可以声明在类级别，也可以声明在<code>@Bean</code>注解的方法，每个bean可能比较独特（就像相同的bean类有多个定义）。<code>@Ordered</code>值可能影响注册点的优先级，但是请知晓它们不影响单例启动顺序，这是由依赖关系和@DependsOn声明确定的正交关注点。</p>
<blockquote>
<p>Note that the standard <code>javax.annotation.Priority</code> annotation is not available at the <code>@Bean</code> level since it cannot be declared on methods. Its semantics can be modeled through <code>@Order</code> values in combination with <code>@Primary</code> on a single bean per type.</p>
</blockquote>
<p>注意标准的<code>javax.annotation.Priority</code>注解在<code>@Bean</code>级别是不适用的，因为它不能声明在方法上。它的语义可以通过@Order值与@Primary结合在每种类型的单个bean上建模。</p>
<blockquote>
<p>Even typed Maps can be autowired as long as the expected key type is <code>String</code>. The Map values will contain all beans of the expected type, and the keys will contain the corresponding bean names:</p>
</blockquote>
<p>即使<code>Map</code>类型也可以被装配，只要期望的<code>key</code>的类型是<code>String</code>。<code>Map</code>值包含所有期望类型的bean，且<code>key</code>包含相应的bean名称</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Map&lt;String, MovieCatalog&gt; movieCatalogs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieCatalogs</span><span class="params">(Map&lt;String, MovieCatalog&gt; movieCatalogs)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieCatalogs = movieCatalogs;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>By default, the autowiring fails whenever <em>zero</em> candidate beans are available; the default behavior is to treat annotated methods, constructors, and fields as indicating <em>required</em> dependencies. This behavior can be changed as demonstrated below.</p>
</blockquote>
<p>默认，只要没有候选bean可用，自动装配失败。该行为也适用于必须依赖项的注解方法，构造方法，域。如何可以更改此行为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Only one constructor of any given bean class may declare <code>@Autowired</code> with the <code>required</code> attribute set to <code>true</code>, indicating <em>the</em> constructor to autowire when used as a Spring bean. Furthermore, if the <code>required</code> attribute is set to <code>true</code>, only a single constructor may be annotated with <code>@Autowired</code>. If multiple <em>non-required</em> constructors declare the annotation, they will be considered as candidates for autowiring. The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary/default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. An annotated constructor does not have to be public. The <code>required</code> attribute of <code>@Autowired</code> is recommended over the <code>@Required</code> annotation on setter methods. The <code>required</code> attribute indicates that the property is not required for autowiring purposes. The property is ignored if it cannot be autowired. <code>@Required</code>, on the other hand, is stronger in that it enforces the property to be set by any means supported by the container. If no value is defined, a corresponding exception is raised.</p>
</blockquote>
<p>对于任何仅有一个构造方法的bean类可以声明<code>@Autowired</code>的<code>required</code>属性为<code>true</code>，表示构造函数用作Spring的bean是可以自动装配。进一步，如果<code>required</code>属性设置为<code>true</code>，只能使用<code>@Autowired</code>注解仅一个的构造方法。如果多个非必须构造函数声明了该注解，他们讲将被作为自动装配的候选者。将选择通过匹配Spring容器中的bean可以满足的依赖关系数量最多的构造函数。如果没有一个候选者满足，则将使用主、默认构造方法（如果有的话）。如果一个类仅声明了一个单一的构造函数，也将始终使用它，即使没有注解。一个注解的构造方法不必是<code>public</code>的，建议在<code>@Required</code>主机的方法上使用<code>Autowired</code>的<code>required</code>属性。<code>required</code>属性表明该属性对于自动装备不是必须的。如果没有被自动装配，该属性将被忽略。<code>@Required</code>，另一方面，更强大，因为它可以通过容器支持的任何方式强制设置属性。如果未定义任何值，则抛出相应的异常。</p>
<blockquote>
<p>Alternatively, you may express the non-required nature of a particular dependency through Java 8’s <code>java.util.Optional</code>:</p>
</blockquote>
<p>另外，您可以通过Java 8来表达特定依赖项的非必需性质</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(Optional&lt;MovieFinder&gt; movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>You can also use <code>@Autowired</code> for interfaces that are well-known resolvable dependencies: <code>BeanFactory</code>, <code>ApplicationContext</code>, <code>Environment</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code>. These interfaces and their extended interfaces, such as <code>ConfigurableApplicationContext</code> or <code>ResourcePatternResolver</code>, are automatically resolved, with no special setup necessary.</p>
</blockquote>
<p>你可以将<code>@Autowired</code>应用于那些众所周知的可解析的依赖接口：<code>BeanFactory</code>，<code>ApplicationContext</code>，<code>Environment</code>，<code>ApplicationContextEventPulisher</code>，和<code>MessageSource</code>。这些接口和它们的扩展接口，比如<code>ConfigurableApplicationContext</code>或者<code>ResourcePatternResolver</code>，将被自动解析，无需特殊必要设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">setup 设置</span></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p><code>@Autowired</code>, <code>@Inject</code>, <code>@Resource</code>, and <code>@Value</code> annotations are handled by Spring <code>BeanPostProcessor</code> implementations which in turn means that you <em>cannot</em> apply these annotations within your own <code>BeanPostProcessor</code> or <code>BeanFactoryPostProcessor</code> types (if any). These types must be ‘wired up’ explicitly via XML or using a Spring <code>@Bean</code> method.</p>
</blockquote>
<p><code>@Autowired</code>，<code>@Inject</code>，<code>@Ressource</code>和<code>@Value</code>注解被Spring的<code>BeanPostProcessor</code>实现处理，反过来意味着，你不能在自己的<code>BeanPostProcessor</code>或者<code>BeanFactoryPostProcessor</code>中装配这些类型（如果有）。这些类型必须通过xml或者使用Spring<code>@Bean</code>方法来装配。</p>
<h3 id="7-9-3-Fine-tuning-annotation-based-autowiring-with-Primary"><a href="#7-9-3-Fine-tuning-annotation-based-autowiring-with-Primary" class="headerlink" title="7.9.3 Fine-tuning annotation-based autowiring with @Primary"></a>7.9.3 Fine-tuning annotation-based autowiring with @Primary</h3><p>使用<code>@Primary</code>微调基于注释的自动装配</p>
<blockquote>
<p>Because autowiring by type may lead to multiple candidates, it is often necessary to have more control over the selection process. One way to accomplish this is with Spring’s <code>@Primary</code> annotation. <code>@Primary</code> indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency. If exactly one ‘primary’ bean exists among the candidates, it will be the autowired value.</p>
</blockquote>
<p>因为基于类型的自动装配可能会导致多个候选依赖，常常有必要对选择的过程进行更多的控制。一种达到此目的的方式是使用Spring的<code>@Primary</code>注解。<code>@Primary</code>注解表明当多个bean候选项要注入到单一值依赖上时，应当给予特定的bean优先级。如果确切的一个<code>primary</code>bean存于候选项其中，它将是被注入的值。</p>
<p>Let’s assume we have the following configuration that defines <code>firstMovieCatalog</code> as the <em>primary</em> <code>MovieCatalog</code>.</p>
<blockquote>
<p>假设有以下配置，定义<code>fistrMovieCatalog</code>作为<code>primary</code>的<code>MovieCatelog</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieConfiguration</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Primary</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">firstMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Bean</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> MovieCatalog <span class="title">secondMovieCatalog</span><span class="params">()</span> </span>&#123; ... &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>With such configuration, the following <code>MovieRecommender</code> will be autowired with the <code>firstMovieCatalog</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The corresponding bean definitions appear as follows.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span> <span class="attr">primary</span>=<span class="string">"true"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="7-9-4-Fine-tuning-annotation-based-autowiring-with-qualifiers"><a href="#7-9-4-Fine-tuning-annotation-based-autowiring-with-qualifiers" class="headerlink" title="7.9.4 Fine-tuning annotation-based autowiring with qualifiers"></a>7.9.4 Fine-tuning annotation-based autowiring with qualifiers</h3><p>使用<code>@Qualifier</code>微调基于注释的自动装配</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">qualifier n. 预选赛，资格赛；限定词，限定语</span></pre></td></tr></table></figure>

<blockquote>
<p><code>@Primary</code> is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When more control over the selection process is required, Spring’s <code>@Qualifier</code> annotation can be used. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument. In the simplest case, this can be a plain descriptive value:</p>
</blockquote>
<p>当可以确定一个候选者时，<code>@Primary</code>是一种有效的方式，按照类型来自动装配。当选择过程需要更多控制时，Spring<code>@Qulifier</code>注解可以使用。你可以将<code>qualifier</code>值与特定的参数联合起来，缩小匹配类型的集合以使得每个参数选择特定的bean。最简单的例子中，这可以是一个简单的描述值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"main"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The <code>@Qualifier</code> annotation can also be specified on individual constructor arguments or method parameters:</p>
<p><code>@Qualifier</code>注解也能指定到构造方法参数或者方法方法参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog movieCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(@Qualifier(<span class="string">"main"</span>)</span>MovieCatalog movieCatalog,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function">            CustomerPreferenceDao customerPreferenceDao) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieCatalog = movieCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.customerPreferenceDao = customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The corresponding bean definitions appear as follows. The bean with qualifier value “main” is wired with the constructor argument that is qualified with the same value.</p>
</blockquote>
<p>相应的bean定义如下。带有<code>main</code>限定词的bean装配到构造函数参数，被限定为相同的值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"main"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">"action"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>For a fallback match, the bean name is considered a default qualifier value. Thus you can define the bean with an id “main” instead of the nested qualifier element, leading to the same matching result. However, although you can use this convention to refer to specific beans by name, <code>@Autowired</code> is fundamentally about type-driven injection with optional semantic qualifiers. This means that qualifier values, even with the bean name fallback, always have narrowing semantics within the set of type matches; they do not semantically express a reference to a unique bean id. Good qualifier values are “main” or “EMEA” or “persistent”, expressing characteristics of a specific component that are independent from the bean <code>id</code>, which may be auto-generated in case of an anonymous bean definition like the one in the preceding example.</p>
</blockquote>
<p>对于备选匹配，bean的名称认定为默认的限定值。因此你可以使用id为main来定义bean而不是使用嵌套的<code>&lt;quailier/&gt;</code>元素，可以达到相同的匹配效果。但是，尽管你可以根据名称使用这种约定来引用bean，<code>@Autowired</code>从根本上说是基于类型驱动注入，带有可选的语义限定符。这意味着限定值，即使用bean名称备选限定符，在类型匹配的集合中始终有较窄的语义。它们没有在语义上对一个唯一bean的id引用。好的限定值是main，EMEA或persistent，表达出特定组件的特点，独立于bean<code>id</code>，在匿明的bean定义中（像之前的例子），可能是自动生成的。</p>
<blockquote>
<p>Qualifiers also apply to typed collections, as discussed above, for example, to <code>Set</code>. In this case, all matching beans according to the declared qualifiers are injected as a collection. This implies that qualifiers do not have to be unique; they rather simply constitute filtering criteria. For example, you can define multiple <code>MovieCatalog</code> beans with the same qualifier value “action”, all of which would be injected into a <code>Set</code> annotated with <code>@Qualifier(&quot;action&quot;)</code>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">constitute v. 构成，组成</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">criteria n. 标准，准则，规范</span></pre></td></tr></table></figure>

<p>限定符也适用于集合类型。像之前提到的，例如<code>Set</code>。该例中，根据声明的限定符，所有匹配的bean作为集合注入。这暗示着限定符不必唯一，它们只构成过滤标准。例如你可以使用相同的限定值action定义多个<code>MovieCatelog</code>实例，所有实例将被注入<code>@Qualifier(&quot;action&quot;)</code>注解的<code>Set</code>中</p>
<blockquote>
<p>Letting qualifier values select against target bean names, within the type-matching candidates, doesn’t even require a <code>@Qualifier</code> annotation at the injection point. If there is no other resolution indicator (e.g. a qualifier or a primary marker), for a non-unique dependency situation, Spring will match the injection point name (i.e. field name or parameter name) against the target bean names and choose the same-named candidate, if any.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">against  针对</span></pre></td></tr></table></figure>

<p>在类型匹配的候选项中，让限定值针对目标bean的名称进行选择，在注入点甚至不需要<code>@Qualifier</code>注解。如果没有其他解析指示符（qualifier或者primary标记），对于非唯一的依赖情况，Spring将针对目标bean名称匹配注入点的名字（比如字段名或者参数名）且选择相同名字的候选项，如果有的话。</p>
<blockquote>
<p>That said, if you intend to express annotation-driven injection by name, do not primarily use <code>@Autowired</code>, even if is capable of selecting by bean name among type-matching candidates. Instead, use the JSR-250 <code>@Resource</code> annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process. <code>@Autowired</code> has rather different semantics: After selecting candidate beans by type, the specified String qualifier value will be considered within those type-selected candidates only, e.g. matching an “account” qualifier against beans marked with the same qualifier label.</p>
</blockquote>
<p>那就是说，如果你想通过名称标识注解驱动的注入，也不要主使用<code>@Autowired</code>，即使可以通过类型匹配，根据名称进行候选。替代其可以使用JSR-250的<code>@Resource</code>注解，语义上根据唯一的名称来定义特定的目标bean，而声明类型与匹配过程无关。<code>@Autowired</code>语义则很大不同：根据类型选择候选项后，仅在那些类型选择后的候选项中考虑指定的字符限定值，例如，将account限定值与具有相同限定符标签的bean匹配。</p>
<blockquote>
<p>For beans that are themselves defined as a collection/map or array type, <code>@Resource</code> is a fine solution, referring to the specific collection or array bean by unique name. That said, as of 4.3, collection/map and array types can be matched through Spring’s <code>@Autowired</code> type matching algorithm as well, as long as the element type information is preserved in <code>@Bean</code> return type signatures or collection inheritance hierarchies. In this case, qualifier values can be used to select among same-typed collections, as outlined in the previous paragraph.</p>
</blockquote>
<p>对于那些自身定义为集合，map或者数组类型的bean，<code>@Resource</code>是个很好的解决方案，通过唯一名称来引用特定的集合或者数组类型。就是说，从4.3开始，集合，map和数组类型可以通过Spring的<code>@Autowired</code>也能根据类型匹配算法进行匹配，只要只要元素类型信息保存到<code>@Bean</code>返回类型签名或者集合继承层次结构中。这种情况下，限定值可以用于在类型相同的集合上选择，如上一段所属。</p>
<blockquote>
<p>As of 4.3, <code>@Autowired</code> also considers self references for injection, i.e. references back to the bean that is currently injected. Note that self injection is a fallback; regular dependencies on other components always have precedence. In that sense, self references do not participate in regular candidate selection and are therefore in particular never primary; on the contrary, they always end up as lowest precedence. In practice, use self references as a last resort only, e.g. for calling other methods on the same instance through the bean’s transactional proxy: Consider factoring out the affected methods to a separate delegate bean in such a scenario. Alternatively, use <code>@Resource</code> which may obtain a proxy back to the current bean by its unique name.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">as of 从...开始</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">precedence n. 优先级，优先权</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">in that sence 在这个意义上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">participate v. 参与，参加</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">on the contrary 相反</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">in practice 实际上</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">alternatively 或者</span></pre></td></tr></table></figure>



<p>从4.3开始，<code>@Autowired</code>也会考虑自身引用注入，比如，回溯到当前注入的bean。注意自我注入是一个备选。对其他组件的常规依赖始终优先。这个意义上说，自我引用不参与常规候选项选择，因此尤其绝不主要。相反，它总是以最低的优先级结束。实际上，使用自我引用作为左后的手段，通过Bean的事务代理在同一实例上调用其他方法的方法：在这种情况下，考虑将受影响的方法分解为单独的委托Bean。或者，使用<code>@Resource</code>，它可以通过其唯一名称获得返回到当前bean的代理。</p>
<blockquote>
<p><code>@Autowired</code> applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. By contrast, <code>@Resource</code> is supported only for fields and bean property setter methods with a single argument. As a consequence, stick with qualifiers if your injection target is a constructor or a multi-argument method.</p>
</blockquote>
<p><code>@Autowired</code>应用于字段，构造方法和多参数方法，通过限定注解在参数级别上缩小范围。相比之下，相比之下，只有单个参数的字段和bean属性设置器方法才支持<code>@Resource</code>。因此，如果注入目标是构造函数或多参数方法，请坚持使用限定符。</p>
<blockquote>
<p>You can create your own custom qualifier annotations. Simply define an annotation and provide the <code>@Qualifier</code> annotation within your definition:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Genre &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Then you can provide the custom qualifier on autowired fields and parameters:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Genre</span>(<span class="string">"Action"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog actionCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog comedyCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setComedyCatalog</span><span class="params">(@Genre(<span class="string">"Comedy"</span>)</span> MovieCatalog comedyCatalog) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.comedyCatalog = comedyCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Next, provide the information for the candidate bean definitions. You can add <code>&lt;qualifier/&gt;</code> tags as sub-elements of the <code>&lt;bean/&gt;</code> tag and then specify the <code>type</code> and <code>value</code> to match your custom qualifier annotations. The type is matched against the fully-qualified class name of the annotation. Or, as a convenience if no risk of conflicting names exists, you can use the short class name. Both approaches are demonstrated in the following example.</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"Genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"example.Genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"movieRecommender"</span> <span class="attr">class</span>=<span class="string">"example.MovieRecommender"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>In <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-classpath-scanning" target="_blank" rel="noopener">Section 7.10, “Classpath scanning and managed components”</a>, you will see an annotation-based alternative to providing the qualifier metadata in XML. Specifically, see <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-scanning-qualifiers" target="_blank" rel="noopener">Section 7.10.8, “Providing qualifier metadata with annotations”</a>.</p>
</blockquote>
<blockquote>
<p>In some cases, it may be sufficient to use an annotation without a value. This may be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an <em>offline</em> catalog that would be searched when no Internet connection is available. First define the simple annotation:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Offline &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>Then add the annotation to the field or property to be autowired:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Offline</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog offlineCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Now the bean definition only needs a qualifier <code>type</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;bean class&#x3D;&quot;example.SimpleMovieCatalog&quot;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    &lt;qualifier type&#x3D;&quot;Offline&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &lt;!-- inject any dependencies required by this bean --&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;&#x2F;bean&gt;</span></pre></td></tr></table></figure>

<blockquote>
<p>You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple <code>value</code> attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match <em>all</em> such attribute values to be considered an autowire candidate. As an example, consider the following annotation definition:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.PARAMETER&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Qualifier</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MovieQualifier &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function">String <span class="title">genre</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function">Format <span class="title">format</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>In this case <code>Format</code> is an enum:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Format &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    VHS, DVD, BLURAY</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>The fields to be autowired are annotated with the custom qualifier and include values for both attributes: <code>genre</code> and <code>format</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Action"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog actionVhsCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.VHS, genre=<span class="string">"Comedy"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog comedyVhsCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.DVD, genre=<span class="string">"Action"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog actionDvdCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@MovieQualifier</span>(format=Format.BLURAY, genre=<span class="string">"Comedy"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieCatalog comedyBluRayCatalog;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>Finally, the bean definitions should contain matching qualifier values. This example also demonstrates that bean <em>meta</em> attributes may be used instead of the <code>sub-elements. If available, the</code> and its attributes take precedence, but the autowiring mechanism falls back on the values provided within the `` tags if no such qualifier is present, as in the last two bean definitions in the following example.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"MovieQualifier"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"VHS"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">type</span>=<span class="string">"MovieQualifier"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"VHS"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">attribute</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">qualifier</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"DVD"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Action"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"example.SimpleMovieCatalog"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"format"</span> <span class="attr">value</span>=<span class="string">"BLURAY"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">key</span>=<span class="string">"genre"</span> <span class="attr">value</span>=<span class="string">"Comedy"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- inject any dependencies required by this bean --&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<h3 id="7-9-5-Using-generics-as-autowiring-qualifiers"><a href="#7-9-5-Using-generics-as-autowiring-qualifiers" class="headerlink" title="7.9.5 Using generics as autowiring qualifiers"></a>7.9.5 Using generics as autowiring qualifiers</h3><h3 id="7-9-6-CustomAutowireConfigurer"><a href="#7-9-6-CustomAutowireConfigurer" class="headerlink" title="7.9.6 CustomAutowireConfigurer"></a>7.9.6 CustomAutowireConfigurer</h3><h3 id="7-9-7-Resource"><a href="#7-9-7-Resource" class="headerlink" title="7.9.7 @Resource"></a>7.9.7 @Resource</h3><blockquote>
<p>Spring also supports injection using the JSR-250 <code>@Resource</code> annotation on fields or bean property setter methods. This is a common pattern in Java EE 5 and 6, for example in JSF 1.2 managed beans or JAX-WS 2.0 endpoints. Spring supports this pattern for Spring-managed objects as well. </p>
</blockquote>
<p>Spring也支持在字段，或者bean属性setter方法上使用JSR-250<code>@Resource</code>注解来进行诸如。这是JavaEE 5和6的常见模式，例如在JSF1.2管理bean或者JAX-WS2.0断点。Spring也支持这种格式来管理对象</p>
<blockquote>
<p><code>@Resource</code> takes a name attribute, and by default Spring interprets that value as the bean name to be injected. In other words, it follows <em>by-name</em> semantics, as demonstrated in this example:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">interpret v. 1.解释;说明;阐释; 2. 口译</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">demonstrate v. 1.证明;论证;表明;说明 2. 显示，表露 3. 示威游行</span></pre></td></tr></table></figure>



<p><code>@Resource</code>有一个<code>name</code>属性，默认Spring将其视为要注入bean的<code>name</code>。换句话说，它遵循根据名称的语义，如本例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span>(name=<span class="string">"myMovieFinder"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>If no name is specified explicitly, the default name is derived from the field name or setter method. In case of a field, it takes the field name; in case of a setter method, it takes the bean property name. So the following example is going to have the bean with name “movieFinder” injected into its setter method:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">derive v. 1. 获得;取得;得到 2. （使）起源于;（使）来自 is derived from...</span></pre></td></tr></table></figure>

<p>如果没有显式指定<code>name</code>，默认的<code>name</code>将来源于字段名或者setter方法。字段的情况下，采用字段名称；setter方法情况下，采用bean的属性名。所以下面的例子将使用名称为<code>movieFinder</code>注入到setter方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMovieFinder</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>The name provided with the annotation is resolved as a bean name by the <code>ApplicationContext</code> of which the <code>CommonAnnotationBeanPostProcessor</code> is aware. The names can be resolved through JNDI if you configure Spring’s <a href="https://docs.spring.io/spring-framework/docs/4.3.25.RELEASE/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html" target="_blank" rel="noopener"><code>SimpleJndiBeanFactory</code></a> explicitly. However, it is recommended that you rely on the default behavior and simply use Spring’s JNDI lookup capabilities to preserve the level of indirection.</p>
</blockquote>
<p>提供给注解的<code>name</code>被<code>CommonAnnotationBeanPostProcessor</code>知晓的<code>ApplicationContext</code>解析为bean的<code>name</code>。如果你显式配置Spring的<code>SimpleJndiBeanFactory</code>，<code>name</code>解析将通过JNDI。但是，建议使用默认的行为，且只需使用Spring的JNDI查找功能来保留间接级别。</p>
<blockquote>
<p>In the exclusive case of <code>@Resource</code> usage with no explicit name specified, and similar to <code>@Autowired</code>, <code>@Resource</code> finds a primary type match instead of a specific named bean and resolves well-known resolvable dependencies: the <code>BeanFactory</code>, <code>ApplicationContext</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code> interfaces.</p>
</blockquote>
<p>在没有显式指定名称的情况下使用<code>@Resource</code>，类似于<code>@Autowired</code>，<code>@Resource</code>查找主类型匹配而不是特定名称的bean，并解析总所周知的可解析的依赖项：<code>BeanFactory</code>, <code>ApplicationContext</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code> 接口.</p>
<blockquote>
<p>Thus in the following example, the <code>customerPreferenceDao</code> field first looks for a bean named customerPreferenceDao, then falls back to a primary type match for the type <code>CustomerPreferenceDao</code>. The “context” field is injected based on the known resolvable dependency type <code>ApplicationContext</code>.</p>
</blockquote>
<p>因此，下面的例子，<code>customerPreferenceDao</code>域首先查找名为<code>customerPreferneceDao</code>的bean，然后回退查找和<code>CustomerPreferenceDao</code>类型相匹配的主类型。<code>context</code>域基于已知的可解析依赖类型的<code>ApplicationContext</code>注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieRecommender</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 * firstly， find by name, secondly by type if not found</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> CustomerPreferenceDao customerPreferenceDao;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Resource</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> ApplicationContext context;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MovieRecommender</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="7-9-8-PostConstruct-and-PreDestroy"><a href="#7-9-8-PostConstruct-and-PreDestroy" class="headerlink" title="7.9.8 @PostConstruct and @PreDestroy"></a>7.9.8 @PostConstruct and @PreDestroy</h3><blockquote>
<p>The <code>CommonAnnotationBeanPostProcessor</code> not only recognizes the <code>@Resource</code> annotation but also the JSR-250 <em>lifecycle</em> annotations. Introduced in Spring 2.5, the support for these annotations offers yet another alternative to those described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#beans-factory-lifecycle-initializingbean" target="_blank" rel="noopener">initialization callbacks</a> and <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/beans.html#beans-factory-lifecycle-disposablebean" target="_blank" rel="noopener">destruction callbacks</a>. Provided that the <code>CommonAnnotationBeanPostProcessor</code> is registered within the Spring <code>ApplicationContext</code>, a method carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding Spring lifecycle interface method or explicitly declared callback method. In the example below, the cache will be pre-populated upon initialization and cleared upon destruction.</p>
</blockquote>
<p><code>CommonAnnotationBeanPostProcessor</code>不仅可以识别<code>@Resource</code>注解，还包括JSR-250生命周期注解。Spring2.5时引入，这些注解的支持为初始化回调和销毁回调中描述的注解提供了另一选择。假设<code>CommonAnnotationBeanPostProcessor</code>已在Spring<code>ApplicationContext</code>中注册，则在生命周期中与相应的Spring生命周期接口方法或显式声明的回调方法在同一时间点调用带有这些注解之一的方法。下面的例子，缓存在初始化是预填充，销毁时清空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachingMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostConstruct</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">populateMovieCache</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// populates the movie cache upon initialization...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PreDestroy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearMovieCache</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// clears the movie cache upon destruction...</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="7-10-Classpath-scanning-and-managed-components"><a href="#7-10-Classpath-scanning-and-managed-components" class="headerlink" title="7.10 Classpath scanning and managed components"></a>7.10 Classpath scanning and managed components</h2><p>类路径扫描和组件管理</p>
<h3 id="7-10-1-Component-and-further-stereotype-annotations"><a href="#7-10-1-Component-and-further-stereotype-annotations" class="headerlink" title="7.10.1 @Component and further stereotype annotations"></a>7.10.1 @Component and further stereotype annotations</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">stereotype n. 模式化的形象(或特征);固定模式;刻板印象;陈规老套</span></pre></td></tr></table></figure>

<blockquote>
<p>The <code>@Repository</code> annotation is a marker for any class that fulfills the role or <em>stereotype</em> of a repository (also known as Data Access Object or DAO). Among the uses of this marker is the automatic translation of exceptions as described in <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/html/orm.html#orm-exception-translation" target="_blank" rel="noopener">Section 20.2.2, “Exception translation”</a>.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">among</span></pre></td></tr></table></figure>

<p><code>@Repository</code>注解是实现了<code>repository</code>角色或者模式的任何类的一个标记（也被称之为数据访问对象<code>DAO</code>）。这个标记的用途之一是自动翻译异常。</p>
<blockquote>
<p>Spring provides further stereotype annotations: <code>@Component</code>, <code>@Service</code>, and <code>@Controller</code>. <code>@Component</code> is a generic stereotype for any Spring-managed component. <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are specializations of <code>@Component</code> for more specific use cases, for example, in the persistence, service, and presentation layers, respectively. Therefore, you can annotate your component classes with <code>@Component</code>, but by annotating them with <code>@Repository</code>, <code>@Service</code>, or <code>@Controller</code> instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts. It is also possible that <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> may carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using <code>@Component</code> or <code>@Service</code> for your service layer, <code>@Service</code> is clearly the better choice. Similarly, as stated above, <code>@Repository</code> is already supported as a marker for automatic exception translation in your persistence layer.</p>
</blockquote>
<p>Spring提供了进一步的模式注解：<code>@Component</code>，<code>@Service</code>，<code>@Controller</code>。<code>@Component</code>是任何Spring管理对象的通用模式注解。<code>@Controller</code>，<code>@Service</code>，<code>@Repository</code>是<code>@Component</code>特殊化，用于更具体的用例，例如分别在控制层，服务层和持久化层。因此，你可以使用<code>@Component</code>来注解你的组件类，但是如果使用<code>@Repository</code>，<code>@Service</code>和<code>@Controller</code>代替，你的类将更适合工具处理或者与其他方面联合。例如这些模式注解提供给了理想目标切点。 <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code>可能携带额外语义在Spring的框架未来版本中。因此如果你为服务层在<code>@Component</code>和<code>@Service</code>之前选择，<code>@Service</code>明显是更好的选择。相似地，像上面描述的，<code>@Repository</code>也是对持久化层自动异常翻译提供支持的标记。</p>
<h3 id="7-10-2-Meta-annotations"><a href="#7-10-2-Meta-annotations" class="headerlink" title="7.10.2 Meta-annotations"></a>7.10.2 Meta-annotations</h3><h3 id="7-10-3-Automatically-detecting-classes-and-registering-bean-definitions"><a href="#7-10-3-Automatically-detecting-classes-and-registering-bean-definitions" class="headerlink" title="7.10.3 Automatically detecting classes and registering bean definitions"></a>7.10.3 Automatically detecting classes and registering bean definitions</h3><blockquote>
<p>Spring can automatically detect stereotyped classes and register corresponding <code>BeanDefinition</code>s with the <code>ApplicationContext</code>. For example, the following two classes are eligible for such autodetection:</p>
</blockquote>
<p>Spring能够自动检测模式注解类并将其注册为<code>ApplicationContext</code>中的<code>BeanDefinition</code>。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleMovieLister</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> MovieFinder movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleMovieLister</span><span class="params">(MovieFinder movieFinder)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.movieFinder = movieFinder;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JpaMovieFinder</span> <span class="keyword">implements</span> <span class="title">MovieFinder</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// implementation elided for clarity</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>To autodetect these classes and register the corresponding beans, you need to add <code>@ComponentScan</code> to your <code>@Configuration</code> class, where the <code>basePackages</code> attribute is a common parent package for the two classes. (Alternatively, you can specify a comma/semicolon/space-separated list that includes the parent package of each class.)</p>
</blockquote>
<p>为了自动检测这些类，并且注册为相应的bean，你需要添加<code>@ComponentScan</code>到你<code>@Configuration</code>类中，这里<code>basePackage</code>是两个类的共同父级包。（或者，可以指定逗号，分号，空格分隔的包含每个类的父级包列表）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"org.example"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span>  </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<blockquote>
<p>For concision, the above may have used the <code>value</code> attribute of the annotation, i.e. <code>@ComponentScan(&quot;org.example&quot;)</code></p>
</blockquote>
<p>为简明起见，以上内容可能使用了注解的<code>value</code>属性，即<code>@ComponentScan(&quot;org.example&quot;)</code></p>
<p>等价的xml配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>/&gt;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>

<blockquote>
<p>The use of <code>&lt;context:component-scan/&gt;</code> implicitly enables the functionality of <code>&lt;context:component-config/&gt;</code>. There is usually no need to include the <code>&lt;context:component-config/&gt;</code> element when using <code>&lt;context:component-scan&gt;</code>.</p>
</blockquote>
<p>使用<code>&lt;context:component-scan/&gt;</code>隐式启用<code>&lt;context:component-config/&gt;</code>功能。当使用<code>&lt;context:component-scan/&gt;</code>时无需引入<code>&lt;context:component-config/&gt;</code></p>
<blockquote>
<p>Furthermore, the <code>AutowiredAnnotationBeanPostProcessor</code> and <code>CommonAnnotationBeanPostProcessor</code> are both included implicitly when you use the component-scan element. That means that the two components are autodetected <em>and</em> wired together - all without any bean configuration metadata provided in XML.</p>
</blockquote>
<p>再者，使用<code>component-scan</code>元素时，<code>AutowiredAnnotationBeanPostProcessor</code>和<code>CommonAnnotationBeanPostProcessor</code>都会被隐式包含（添加到<code>ApplicationContext</code>）。也就是说这两个组件会一起被自动检测和装配。都不用在xml配置任何bean的元数据。</p>
<blockquote>
<p>You can disable the registration of <code>AutowiredAnnotationBeanPostProcessor</code> and <code>CommonAnnotationBeanPostProcessor</code> by including the <em>annotation-config</em> attribute with a value of <code>false</code>.</p>
</blockquote>
<h2 id="7-11-Using-JSR-330-Standard-Annotations"><a href="#7-11-Using-JSR-330-Standard-Annotations" class="headerlink" title="7.11 Using JSR 330 Standard Annotations"></a>7.11 Using JSR 330 Standard Annotations</h2><p><strong>Table 7.6. Spring component model elements vs. JSR-330 variants</strong></p>
<table>
<thead>
<tr>
<th>Spring</th>
<th>javax.inject.*</th>
<th>javax.inject restrictions / comments</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td><code>@Inject</code></td>
<td><code>@Inject</code> has no ‘required’ attribute; can be used with Java 8’s <code>Optional</code> instead.</td>
</tr>
<tr>
<td><code>@Component</code></td>
<td><code>@Named</code> / <code>@ManagedBean</code></td>
<td>JSR-330 does not provide a composable model, just a way to identify named components.</td>
</tr>
<tr>
<td><code>@Scope(&quot;singleton&quot;)</code></td>
<td><code>@Singleton</code></td>
<td>The JSR-330 default scope is like Spring’s <code>prototype</code>. However, in order to keep it consistent with Spring’s general defaults, a JSR-330 bean declared in the Spring container is a <code>singleton</code> by default. In order to use a scope other than <code>singleton</code>, you should use Spring’s <code>@Scope</code> annotation. <code>javax.inject</code> also provides a <a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html" target="_blank" rel="noopener">@Scope</a> annotation. Nevertheless, this one is only intended to be used for creating your own annotations.</td>
</tr>
<tr>
<td><code>@Qualifier</code></td>
<td><code>@Qualifier</code> /<code>@Named</code></td>
<td><code>javax.inject.Qualifier</code> is just a meta-annotation for building custom qualifiers. Concrete String qualifiers (like Spring’s <code>@Qualifier</code> with a value) can be associated through <code>javax.inject.Named</code>.</td>
</tr>
<tr>
<td><code>@Value</code></td>
<td>-</td>
<td>no equivalent</td>
</tr>
<tr>
<td><code>@Required</code></td>
<td>-</td>
<td>no equivalent</td>
</tr>
<tr>
<td><code>@Lazy</code></td>
<td>-</td>
<td>no equivalent</td>
</tr>
<tr>
<td><code>ObjectFactory</code></td>
<td><code>Provider</code></td>
<td><code>javax.inject.Provider</code> is a direct alternative to Spring’s <code>ObjectFactory</code>, just with a shorter <code>get()</code> method name. It can also be used in combination with Spring’s <code>@Autowired</code> or with non-annotated constructors and setter methods.</td>
</tr>
</tbody></table>
<h3 id="7-11-3-Limitations-of-JSR-330-standard-annotations"><a href="#7-11-3-Limitations-of-JSR-330-standard-annotations" class="headerlink" title="7.11.3 Limitations of JSR-330 standard annotations"></a>7.11.3 Limitations of JSR-330 standard annotations</h3><h2 id="7-12-Java-based-container-configuration"><a href="#7-12-Java-based-container-configuration" class="headerlink" title="7.12 Java-based container configuration"></a>7.12 Java-based container configuration</h2><h3 id="7-12-1-Basic-concepts-Bean-and-Configuration"><a href="#7-12-1-Basic-concepts-Bean-and-Configuration" class="headerlink" title="7.12.1 Basic concepts: @Bean and @Configuration"></a>7.12.1 Basic concepts: @Bean and @Configuration</h3><h3 id="7-12-2-Instantiating-the-Spring-container-using-AnnotationConfigApplicationContext"><a href="#7-12-2-Instantiating-the-Spring-container-using-AnnotationConfigApplicationContext" class="headerlink" title="7.12.2 Instantiating the Spring container using AnnotationConfigApplicationContext"></a>7.12.2 Instantiating the Spring container using AnnotationConfigApplicationContext</h3><h3 id="7-12-3-Using-the-Bean-annotation"><a href="#7-12-3-Using-the-Bean-annotation" class="headerlink" title="7.12.3 Using the @Bean annotation"></a>7.12.3 Using the @Bean annotation</h3><h3 id="7-12-4-Using-the-Configuration-annotation"><a href="#7-12-4-Using-the-Configuration-annotation" class="headerlink" title="7.12.4 Using the @Configuration annotation"></a>7.12.4 Using the @Configuration annotation</h3><h3 id="7-12-5-Composing-Java-based-configurations"><a href="#7-12-5-Composing-Java-based-configurations" class="headerlink" title="7.12.5 Composing Java-based configurations"></a>7.12.5 Composing Java-based configurations</h3><h2 id="7-13-Environment-abstraction"><a href="#7-13-Environment-abstraction" class="headerlink" title="7.13 Environment abstraction"></a>7.13 Environment abstraction</h2><h2 id="7-14-Registering-a-LoadTimeWeaver"><a href="#7-14-Registering-a-LoadTimeWeaver" class="headerlink" title="7.14 Registering a LoadTimeWeaver"></a>7.14 Registering a LoadTimeWeaver</h2><h2 id="7-15-Additional-capabilities-of-the-ApplicationContext"><a href="#7-15-Additional-capabilities-of-the-ApplicationContext" class="headerlink" title="7.15 Additional capabilities of the ApplicationContext"></a>7.15 Additional capabilities of the ApplicationContext</h2><p><code>ApplicationContext</code>其他，附加功能</p>
<h2 id="7-16-The-BeanFactory"><a href="#7-16-The-BeanFactory" class="headerlink" title="7.16 The BeanFactory"></a>7.16 The BeanFactory</h2><p><code>BeanFactory</code></p>
<blockquote>
<p>The <code>BeanFactory</code> API provides the underlying basis for Spring’s IoC functionality. Its specific contracts are mostly used in integration with other parts of Spring and related third-party frameworks, and its <code>DefaultListableBeanFactory</code> implementation is a key delegate within the higher-level <code>GenericApplicationContext</code> container.</p>
</blockquote>
<p><code>BeanFactory</code>API为Spring IoC功能提供了基础。它特定的规约主要用于Spring其他部分以及第三方框架集成，它的<code>DefaultListableBeanFactory</code>实现是更高级别的<code>GenericApplicationContext</code>容器中的关键委托</p>
<blockquote>
<p><code>GenericApplicationContext</code>和<code>DefaultListableBeanFactory</code>都实现了<code>BeanFactory</code>接口，<code>GenericApplicationContext</code>中调用<code>getBean()</code>其实是调用内部持有的<code>DefaultListableBeanFactory</code>真正实现的<code>getBean()</code></p>
</blockquote>
<blockquote>
<p><code>BeanFactory</code> and related interfaces such as <code>BeanFactoryAware</code>, <code>InitializingBean</code>, <code>DisposableBean</code> are important integration points for other framework components: not requiring any annotations or even reflection, they allow for very efficient interaction between the container and its components. Application-level beans may use the same callback interfaces but will typically prefer declarative dependency injection instead, either via annotations or through programmatic configuration.</p>
</blockquote>
<p><code>BeanFactory</code>及其相关接口比如<code>BeanFactoryAware</code>，<code>InitializingBean</code>，<code>DisposableBean</code>都是其他框架组件的重要整合点：不需要任何注解，甚至反射，它们允许容器和其组件间高效交互。应用级别的bean可能使用相同的回调接口，但是通常更喜欢声明式依赖注入，通过注解或者以程序配置的方式</p>
<blockquote>
<p>Note that the core <code>BeanFactory</code> API level and its <code>DefaultListableBeanFactory</code> implementation do not make assumptions about the configuration format or any component annotations to be used. All of these flavors come in through extensions such as <code>XmlBeanDefinitionReader</code> and <code>AutowiredAnnotationBeanPostProcessor</code>, operating on shared <code>BeanDefinition</code> objects as a core metadata representation. This is the essence of what makes Spring’s container so flexible and extensible.</p>
</blockquote>
<p>请注意，核心的BeanFactory API级别及其DefaultListableBeanFactory实现不对配置格式或要使用的任何组件注解进行假设。所有这些flavors都是通过诸如<code>XmlBeanDefinitionReader</code>和<code>AutowiredAnnotationBeanPostProcessor</code>之类的扩展引入的，这些扩展运行在作为核心元数据表示的，共享的<code>BeanDefinition</code>对象上，这是使得Spring容器如此灵活和可扩展的本质。</p>
<blockquote>
<p>The following section explains the differences between the <code>BeanFactory</code> and <code>ApplicationContext</code> container levels and the implications on bootstrapping.</p>
</blockquote>
<h3 id="7-16-1-BeanFactory-or-ApplicationContext"><a href="#7-16-1-BeanFactory-or-ApplicationContext" class="headerlink" title="7.16.1 BeanFactory or ApplicationContext?"></a>7.16.1 BeanFactory or ApplicationContext?</h3><blockquote>
<p>Use an <code>ApplicationContext</code> unless you have a good reason for not doing so, with <code>GenericApplicationContext</code> and its subclass <code>AnnotationConfigApplicationContext</code> as the common implementations for custom bootstrapping. These are the primary entry points to Spring’s core container for all common purposes: loading of configuration files, triggering a classpath scan, programmatically registering bean definitions and annotated classes.</p>
</blockquote>
<p>除非有充分的理由，否则应该使用<code>ApplicationContext</code>，将<code>GenericApplicationContext</code>及其子类<code>AnnotationConfigApplicationContext</code>作为自定义引导的常用实现。这些是所有用于常见目的的Spring核心容器的主要入口：加载配置文件，触发类路径扫描，以程序的方式注册bean定义和注解类</p>
<blockquote>
<p>Because an <code>ApplicationContext</code> includes all functionality of a <code>BeanFactory</code>, it is generally recommended over a plain <code>BeanFactory</code>, except for a scenarios where full control over bean processing is needed. Within an <code>ApplicationContext</code> such as the <code>GenericApplicationContext</code> implementation, several kinds of beans will be detected by convention (i.e. by bean name or by bean type), in particular post-processors, whereas a plain <code>DefaultListableBeanFactory</code> is agnostic about any special beans.</p>
</blockquote>
<p>因为<code>ApplicationContext</code>包含了<code>BeanFactory</code>的所有功能，通常建议不使用普通的<code>BeanFactory</code>, 除非需要完全控制bean处理的场景。在<code>AplicationContext</code>中，例如<code>GenericApplicationContext</code>实现，通过约定（根据名称或者类型）检测到几种bean，在特定的后置处理器中，然而，普通的<code>DefaultListableBeanFactory</code>与任何特殊bean无关。</p>
<blockquote>
<p>For many extended container features such as annotation processing and AOP proxying, the <a href="https://docs.spring.io/spring/docs/4.3.25.RELEASE/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp" target="_blank" rel="noopener"><code>BeanPostProcessor</code> extension point</a> is essential. If you use only a plain <code>DefaultListableBeanFactory</code>, such post-processors will not get detected and activated by default. This situation could be confusing because nothing is actually wrong with your bean configuration; it is rather the container which needs to be fully bootstrapped through additional setup in such a scenario.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">essential adj.绝对必要的;必不可少的;基本的</span></pre></td></tr></table></figure>



<p>对于许多扩展的容器功能诸如注解处理和AOP代理，<code>BeanPostProcessor</code>扩展点必不可少。如果仅使用普通的<code>DefaultListableBeanFactory</code>，则默认情况下不会检测到此类后处理器并将其激活。这种情况可能会造成混乱，因为实际的bean定义并没有错。这种场景下，需要通过附件设置来全面引导容器。</p>
<blockquote>
<p>The following table lists features provided by the <code>BeanFactory</code> and <code>ApplicationContext</code> interfaces and implementations.</p>
</blockquote>
<p><strong>Table 7.9. Feature Matrix</strong></p>
<p>功能矩阵</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th><code>BeanFactory</code></th>
<th><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody><tr>
<td>Bean instantiation/wiring</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>Integrated lifecycle management</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Automatic <code>BeanPostProcessor</code> registration</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Automatic <code>BeanFactoryPostProcessor</code> registration</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Convenient <code>MessageSource</code> access (for internalization)</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Built-in <code>ApplicationEvent</code> publication mechanism</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody></table>
<blockquote>
<p>To explicitly register a bean post-processor with a <code>DefaultListableBeanFactory</code>, you need to programmatically call <code>addBeanPostProcessor</code>:</p>
</blockquote>
<p>使用<code>DefaultListableBeanFactory</code>显式注册一个bean后置处理器，需要以编程的方式调用<code>addBeanPostProcessor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// populate the factory with bean definitions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// now register any needed BeanPostProcessor instances</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">factory.addBeanPostProcessor(<span class="keyword">new</span> AutowiredAnnotationBeanPostProcessor());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">factory.addBeanPostProcessor(<span class="keyword">new</span> MyBeanPostProcessor());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// now start using the factory</span></span></pre></td></tr></table></figure>

<blockquote>
<p>To apply a <code>BeanFactoryPostProcessor</code> to a plain <code>DefaultListableBeanFactory</code>, you need to call its <code>postProcessBeanFactory</code> method:</p>
</blockquote>
<p>为了将<code>BeanFactoryPostProcessor</code>应用到普通的<code>DefaultListableBeanFactory</code>，需要调用<code>postProcessBeanFactory</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">reader.loadBeanDefinitions(<span class="keyword">new</span> FileSystemResource(<span class="string">"beans.xml"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// bring in some property values from a Properties file</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">PropertyPlaceholderConfigurer cfg = <span class="keyword">new</span> PropertyPlaceholderConfigurer();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cfg.setLocation(<span class="keyword">new</span> FileSystemResource(<span class="string">"jdbc.properties"</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// now actually do the replacement</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cfg.postProcessBeanFactory(factory);</span></pre></td></tr></table></figure>

<blockquote>
<p>In both cases, the explicit registration steps are inconvenient, which is why the various <code>ApplicationContext</code> variants are preferred over a plain <code>DefaultListableBeanFactory</code> in Spring-backed applications, especially when relying on <code>BeanFactoryPostProcessor</code>s and <code>BeanPostProcessor</code>s for extended container functionality in a typical enterprise setup.</p>
</blockquote>
<p>在这两种情况下，显式的注册步骤都是不方便的，这就是为什么在Spring支持的应用程序中，相对于普通的DefaultListableBeanFactory，首选各种ApplicationContext变体，尤其是在依赖BeanFactoryPostProcessor和BeanPostProcessor的扩展容器时更是如此。</p>
<h3 id="7-16-2-Glue-code-and-the-evil-singleton"><a href="#7-16-2-Glue-code-and-the-evil-singleton" class="headerlink" title="7.16.2 Glue code and the evil singleton"></a>7.16.2 Glue code and the evil singleton</h3>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/12/07/hello-world/" rel="prev" title="Hello World">
      <i class="fa fa-chevron-left"></i> Hello World
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/12/15/7.%20The%20IoC%20container/" rel="next" title="7. The IoC container">
      7. The IoC container <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#7-The-IoC-container"><span class="nav-number">1.</span> <span class="nav-text">7. The IoC container</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Introduction-to-the-Spring-IoC-container-and-beans"><span class="nav-number">1.1.</span> <span class="nav-text">7.1 Introduction to the Spring IoC container and beans</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-Container-overview"><span class="nav-number">1.2.</span> <span class="nav-text">7.2 Container overview</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-Configuration-metadata"><span class="nav-number">1.2.1.</span> <span class="nav-text">7.2.1 Configuration metadata</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-Instantiating-a-container"><span class="nav-number">1.2.2.</span> <span class="nav-text">7.2.2 Instantiating a container</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Composing-XML-based-configuration-metadata"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Composing XML-based configuration metadata</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-Using-the-container"><span class="nav-number">1.2.3.</span> <span class="nav-text">7.2.3 Using the container</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-Bean-overview"><span class="nav-number">1.3.</span> <span class="nav-text">7.3 Bean overview</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-Naming-beans"><span class="nav-number">1.3.1.</span> <span class="nav-text">7.3.1 Naming beans</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Aliasing-a-bean-outside-the-bean-definition"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">Aliasing a bean outside the bean definition</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-Instantiating-beans"><span class="nav-number">1.3.2.</span> <span class="nav-text">7.3.2 Instantiating beans</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Instantiation-with-a-constructor"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">Instantiation with a constructor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Instantiation-with-a-static-factory-method"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Instantiation with a static factory method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Instantiation-using-an-instance-factory-method"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">Instantiation using an instance factory method</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-Dependencies"><span class="nav-number">1.4.</span> <span class="nav-text">7.4 Dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-Dependency-Injection"><span class="nav-number">1.4.1.</span> <span class="nav-text">7.4.1 Dependency Injection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Constructor-based-dependency-injection"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">Constructor-based dependency injection</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Constructor-argument-resolution"><span class="nav-number">1.4.1.1.1.</span> <span class="nav-text">Constructor argument resolution</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Setter-based-dependency-injection"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">Setter-based dependency injection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dependency-resolution-process"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">Dependency resolution process</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Examples-of-dependency-injection"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">Examples of dependency injection</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-Dependencies-and-configuration-in-detail"><span class="nav-number">1.4.2.</span> <span class="nav-text">7.4.2 Dependencies and configuration in detail</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Straight-values-primitives-Strings-and-so-on"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">Straight values (primitives, Strings, and so on)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#The-idref-element"><span class="nav-number">1.4.2.1.1.</span> <span class="nav-text">The idref element</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#References-to-other-beans-collaborators"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">References to other beans (collaborators)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inner-beans"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">Inner beans</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Collections"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Collection-merging"><span class="nav-number">1.4.2.4.1.</span> <span class="nav-text">Collection merging</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Limitations-of-collection-merging"><span class="nav-number">1.4.2.4.2.</span> <span class="nav-text">Limitations of collection merging</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Strongly-typed-collection"><span class="nav-number">1.4.2.4.3.</span> <span class="nav-text">Strongly-typed collection</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Null-and-empty-string-values"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">Null and empty string values</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML-shortcut-with-the-p-namespace"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">XML shortcut with the p-namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML-shortcut-with-the-c-namespace"><span class="nav-number">1.4.2.7.</span> <span class="nav-text">XML shortcut with the c-namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Compound-property-names"><span class="nav-number">1.4.2.8.</span> <span class="nav-text">Compound property names</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-Using-depends-on"><span class="nav-number">1.4.3.</span> <span class="nav-text">7.4.3 Using depends-on</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-4-Lazy-initialized-beans"><span class="nav-number">1.4.4.</span> <span class="nav-text">7.4.4 Lazy-initialized beans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-5-Autowiring-collaborators"><span class="nav-number">1.4.5.</span> <span class="nav-text">7.4.5 Autowiring collaborators</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Limitations-and-disadvantages-of-autowiring"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">Limitations and disadvantages of autowiring</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Excluding-a-bean-from-autowiring"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">Excluding a bean from autowiring</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-6-Method-injection"><span class="nav-number">1.4.6.</span> <span class="nav-text">7.4.6 Method injection</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lookup-method-injection"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">Lookup method injection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arbitrary-method-replacement"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">Arbitrary method replacement</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-5-Bean-scopes"><span class="nav-number">1.5.</span> <span class="nav-text">7.5 Bean scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-1-The-singleton-scope"><span class="nav-number">1.5.1.</span> <span class="nav-text">7.5.1 The singleton scope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-2-The-prototype-scope"><span class="nav-number">1.5.2.</span> <span class="nav-text">7.5.2 The prototype scope</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-3-Singleton-beans-with-prototype-bean-dependencies"><span class="nav-number">1.5.3.</span> <span class="nav-text">7.5.3 Singleton beans with prototype-bean dependencies</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-4-Request-session-global-session-application-and-WebSocket-scopes"><span class="nav-number">1.5.4.</span> <span class="nav-text">7.5.4 Request, session, global session, application, and WebSocket scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Initial-web-configuration"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">Initial web configuration</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Request-scope"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">Request scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Session-scope"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">Session scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Global-session-scope"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">Global session scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Application-scope"><span class="nav-number">1.5.4.5.</span> <span class="nav-text">Application scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scoped-beans-as-dependencies"><span class="nav-number">1.5.4.6.</span> <span class="nav-text">Scoped beans as dependencies</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Choosing-the-type-of-proxy-to-create"><span class="nav-number">1.5.4.6.1.</span> <span class="nav-text">Choosing the type of proxy to create</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-5-5-Custom-scopes"><span class="nav-number">1.5.5.</span> <span class="nav-text">7.5.5 Custom scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Creating-a-custom-scope"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">Creating a custom scope</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Using-a-custom-scope"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">Using a custom scope</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-6-Customizing-the-nature-of-a-bean"><span class="nav-number">1.6.</span> <span class="nav-text">7.6 Customizing the nature of a bean</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-1-Lifecycle-callbacks"><span class="nav-number">1.6.1.</span> <span class="nav-text">7.6.1 Lifecycle callbacks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Initialization-callbacks"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">Initialization callbacks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Destruction-callbacks"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">Destruction callbacks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Default-initialization-and-destroy-methods"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">Default initialization and destroy methods</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Combining-lifecycle-mechanisms"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">Combining lifecycle mechanisms</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Startup-and-shutdown-callbacks"><span class="nav-number">1.6.1.5.</span> <span class="nav-text">Startup and shutdown callbacks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Shutting-down-the-Spring-IoC-container-gracefully-in-non-web-applications"><span class="nav-number">1.6.1.6.</span> <span class="nav-text">Shutting down the Spring IoC container gracefully in non-web applications</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-2-ApplicationContextAware-and-BeanNameAware"><span class="nav-number">1.6.2.</span> <span class="nav-text">7.6.2 ApplicationContextAware and BeanNameAware</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-6-3-Other-Aware-interfaces"><span class="nav-number">1.6.3.</span> <span class="nav-text">7.6.3 Other Aware interfaces</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-7-Bean-definition-inheritance"><span class="nav-number">1.7.</span> <span class="nav-text">7.7 Bean definition inheritance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-8-Container-Extension-Points"><span class="nav-number">1.8.</span> <span class="nav-text">7.8 Container Extension Points</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-1-Customizing-beans-using-a-BeanPostProcessor"><span class="nav-number">1.8.1.</span> <span class="nav-text">7.8.1 Customizing beans using a BeanPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-Hello-World-BeanPostProcessor-style"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">Example: Hello World, BeanPostProcessor-style</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-The-RequiredAnnotationBeanPostProcessor"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">Example: The RequiredAnnotationBeanPostProcessor</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-2-Customizing-configuration-metadata-with-a-BeanFactoryPostProcessor"><span class="nav-number">1.8.2.</span> <span class="nav-text">7.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-the-Class-name-substitution-PropertyPlaceholderConfigurer"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">Example: the Class name substitution PropertyPlaceholderConfigurer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Example-the-PropertyOverrideConfigurer"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">Example: the PropertyOverrideConfigurer</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-8-3-Customizing-instantiation-logic-with-a-FactoryBean"><span class="nav-number">1.8.3.</span> <span class="nav-text">7.8.3 Customizing instantiation logic with a FactoryBean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-9-Annotation-based-container-configuration"><span class="nav-number">1.9.</span> <span class="nav-text">7.9 Annotation-based container configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-1-Required"><span class="nav-number">1.9.1.</span> <span class="nav-text">7.9.1 @Required</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-2-Autowired"><span class="nav-number">1.9.2.</span> <span class="nav-text">7.9.2 @Autowired</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-3-Fine-tuning-annotation-based-autowiring-with-Primary"><span class="nav-number">1.9.3.</span> <span class="nav-text">7.9.3 Fine-tuning annotation-based autowiring with @Primary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-4-Fine-tuning-annotation-based-autowiring-with-qualifiers"><span class="nav-number">1.9.4.</span> <span class="nav-text">7.9.4 Fine-tuning annotation-based autowiring with qualifiers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-5-Using-generics-as-autowiring-qualifiers"><span class="nav-number">1.9.5.</span> <span class="nav-text">7.9.5 Using generics as autowiring qualifiers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-6-CustomAutowireConfigurer"><span class="nav-number">1.9.6.</span> <span class="nav-text">7.9.6 CustomAutowireConfigurer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-7-Resource"><span class="nav-number">1.9.7.</span> <span class="nav-text">7.9.7 @Resource</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-9-8-PostConstruct-and-PreDestroy"><span class="nav-number">1.9.8.</span> <span class="nav-text">7.9.8 @PostConstruct and @PreDestroy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-10-Classpath-scanning-and-managed-components"><span class="nav-number">1.10.</span> <span class="nav-text">7.10 Classpath scanning and managed components</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-10-1-Component-and-further-stereotype-annotations"><span class="nav-number">1.10.1.</span> <span class="nav-text">7.10.1 @Component and further stereotype annotations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-10-2-Meta-annotations"><span class="nav-number">1.10.2.</span> <span class="nav-text">7.10.2 Meta-annotations</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-10-3-Automatically-detecting-classes-and-registering-bean-definitions"><span class="nav-number">1.10.3.</span> <span class="nav-text">7.10.3 Automatically detecting classes and registering bean definitions</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-11-Using-JSR-330-Standard-Annotations"><span class="nav-number">1.11.</span> <span class="nav-text">7.11 Using JSR 330 Standard Annotations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-11-3-Limitations-of-JSR-330-standard-annotations"><span class="nav-number">1.11.1.</span> <span class="nav-text">7.11.3 Limitations of JSR-330 standard annotations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-12-Java-based-container-configuration"><span class="nav-number">1.12.</span> <span class="nav-text">7.12 Java-based container configuration</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-12-1-Basic-concepts-Bean-and-Configuration"><span class="nav-number">1.12.1.</span> <span class="nav-text">7.12.1 Basic concepts: @Bean and @Configuration</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-12-2-Instantiating-the-Spring-container-using-AnnotationConfigApplicationContext"><span class="nav-number">1.12.2.</span> <span class="nav-text">7.12.2 Instantiating the Spring container using AnnotationConfigApplicationContext</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-12-3-Using-the-Bean-annotation"><span class="nav-number">1.12.3.</span> <span class="nav-text">7.12.3 Using the @Bean annotation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-12-4-Using-the-Configuration-annotation"><span class="nav-number">1.12.4.</span> <span class="nav-text">7.12.4 Using the @Configuration annotation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-12-5-Composing-Java-based-configurations"><span class="nav-number">1.12.5.</span> <span class="nav-text">7.12.5 Composing Java-based configurations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-13-Environment-abstraction"><span class="nav-number">1.13.</span> <span class="nav-text">7.13 Environment abstraction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-14-Registering-a-LoadTimeWeaver"><span class="nav-number">1.14.</span> <span class="nav-text">7.14 Registering a LoadTimeWeaver</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-15-Additional-capabilities-of-the-ApplicationContext"><span class="nav-number">1.15.</span> <span class="nav-text">7.15 Additional capabilities of the ApplicationContext</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-16-The-BeanFactory"><span class="nav-number">1.16.</span> <span class="nav-text">7.16 The BeanFactory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-16-1-BeanFactory-or-ApplicationContext"><span class="nav-number">1.16.1.</span> <span class="nav-text">7.16.1 BeanFactory or ApplicationContext?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-16-2-Glue-code-and-the-evil-singleton"><span class="nav-number">1.16.2.</span> <span class="nav-text">7.16.2 Glue code and the evil singleton</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
